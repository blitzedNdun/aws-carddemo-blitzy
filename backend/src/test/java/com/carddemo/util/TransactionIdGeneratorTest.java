/*
 * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * SPDX-License-Identifier: Apache-2.0
 */

package com.carddemo.util;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.RepeatedTest;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.ValueSource;
import org.mockito.MockedStatic;
import org.mockito.Mockito;

import com.carddemo.test.AbstractBaseTest;
import com.carddemo.test.UnitTest;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;
import static org.assertj.core.api.Assertions.assertThatCode;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.doReturn;
import static org.mockito.Mockito.doThrow;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CyclicBarrier;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicLong;
import java.util.Set;
import java.util.HashSet;
import java.util.List;
import java.util.ArrayList;
import java.util.Collections;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

/**
 * Comprehensive unit test suite for TransactionIdGenerator utility class.
 * 
 * This test class validates transaction ID generation utilities that create unique
 * transaction identifiers matching COBOL VSAM KSDS key patterns and ensuring no 
 * collisions in high-volume scenarios up to 10,000 TPS.
 * 
 * Test Coverage Areas:
 * - Unique ID generation under concurrent access scenarios
 * - Format validation matching VSAM key requirements (16-character format)
 * - Sequence number handling and rollover behavior
 * - Timestamp-based ID component validation for uniqueness
 * - Thread-safety in high-volume scenarios (10,000 TPS performance requirement)
 * - ID collision detection and prevention mechanisms
 * - Performance testing for ID generation speed and efficiency
 * - Compatibility with existing COBOL-generated transaction IDs
 * - Proper handling of ID exhaustion scenarios and overflow conditions
 * 
 * COBOL Integration Requirements:
 * Based on analysis of COBIL00C.cbl and CVTRA05Y.cpy, transaction IDs follow
 * sequential increment pattern where new IDs are generated by:
 * 1. Finding highest existing transaction ID via STARTBR/READPREV
 * 2. Incrementing the numeric value by 1
 * 3. Formatting as 16-character alphanumeric identifier
 * 
 * Performance Requirements:
 * - Must support 10,000 transactions per second (TPS) generation rate
 * - Response time must be under 200ms for ID generation operations
 * - Thread-safe concurrent access with no ID collisions
 * - Memory efficient with minimal GC pressure under load
 * 
 * Validation Requirements:
 * - Generated IDs must match COBOL PIC X(16) format exactly
 * - Sequential ordering must be maintained across concurrent threads
 * - Duplicate ID detection must be 100% reliable
 * - Rollover handling must prevent ID exhaustion
 * 
 * @author CardDemo Migration Team
 * @version 1.0
 * @since CardDemo v1.0
 */
@Tag("unit")
public class TransactionIdGeneratorTest extends AbstractBaseTest implements UnitTest {

    // Pattern for validating 16-character COBOL-compatible transaction ID format
    private static final Pattern TRANSACTION_ID_PATTERN = Pattern.compile("^[A-Z0-9]{16}$");
    
    // Performance testing constants
    private static final int HIGH_VOLUME_THREAD_COUNT = 100;
    private static final int TRANSACTIONS_PER_THREAD = 100;
    private static final int TOTAL_HIGH_VOLUME_TRANSACTIONS = HIGH_VOLUME_THREAD_COUNT * TRANSACTIONS_PER_THREAD;
    private static final long PERFORMANCE_TEST_TIMEOUT_SECONDS = 30;
    
    // Additional constants not yet available in TestConstants.java
    private static final long RESPONSE_TIME_THRESHOLD_MS = 200; // 200ms response time requirement
    private static final int THROUGHPUT_TPS_TARGET = 10000; // 10,000 TPS performance target
    private static final String[] COBOL_COMP3_PATTERNS = {
        "^[0-9]{16}$",        // Pure numeric pattern
        "^[A-Z0-9]{16}$",     // Alphanumeric pattern
        "^[0-9]{8}[A-Z0-9]{8}$" // Mixed pattern with numeric prefix
    };
    private static final double[] VALIDATION_THRESHOLDS = {
        0.95,  // 95% success rate threshold
        0.99,  // 99% accuracy threshold
        0.999  // 99.9% availability threshold
    };
    
    // Transaction ID generation instance under test
    private TransactionIdGenerator transactionIdGenerator;
    
    // Mock dependencies for isolation testing
    private MockedStatic<LocalDateTime> mockedLocalDateTime;
    
    /**
     * Setup method executed before each test execution.
     * Initializes TransactionIdGenerator instance and mock dependencies,
     * ensuring consistent test environment for ID generation validation.
     * 
     * Inherits from AbstractBaseTest to provide common test functionality
     * including mock object management and test data setup.
     */
    @BeforeEach
    public void setUp() {
        // Call parent setup for mock initialization and test fixtures
        super.setUp();
        
        // Initialize the TransactionIdGenerator instance for testing
        // Note: Assuming default constructor - will test actual API when available
        transactionIdGenerator = new TransactionIdGenerator();
        
        // Setup time mocking for timestamp component testing
        setupTimeMocks();
        
        logTestExecution("TransactionIdGeneratorTest setup completed", null);
    }

    /**
     * Teardown method executed after each test execution.
     * Performs cleanup of mock objects and test resources,
     * ensuring proper test isolation and resource management.
     */
    @AfterEach
    public void tearDown() {
        // Close time mocks if active
        if (mockedLocalDateTime != null) {
            mockedLocalDateTime.close();
        }
        
        // Reset transaction ID generator sequence for test isolation
        // This ensures each test starts with a clean sequence state
        if (transactionIdGenerator != null) {
            transactionIdGenerator.resetSequence();
        }
        
        // Call parent teardown for common cleanup
        super.tearDown();
        
        logTestExecution("TransactionIdGeneratorTest teardown completed", null);
    }

    /**
     * Test that generateTransactionId() produces unique transaction identifiers.
     * 
     * This test validates the core requirement for unique ID generation by generating
     * multiple transaction IDs and verifying no duplicates exist. Tests both sequential
     * and concurrent generation scenarios to ensure uniqueness is maintained.
     * 
     * Validates:
     * - Each generated ID is unique within a set of generated IDs
     * - Generated IDs follow the required 16-character format
     * - Generated IDs are non-null and non-empty
     * - Sequential generation maintains uniqueness over time
     * 
     * COBOL Equivalence:
     * Matches COBOL behavior where TRAN-ID is incremented sequentially using
     * STARTBR/READPREV to find highest existing ID, then ADD 1 TO WS-TRAN-ID-NUM.
     */
    @Test
    @DisplayName("generateTransactionId() produces unique identifiers matching COBOL sequential pattern")
    public void testGenerateUniqueTransactionId() {
        // Given: Multiple ID generation requests
        final int numberOfIds = 1000;
        Set<String> generatedIds = new HashSet<>();
        
        // When: Generating multiple transaction IDs sequentially
        for (int i = 0; i < numberOfIds; i++) {
            String transactionId = transactionIdGenerator.generateTransactionId();
            
            // Then: Each ID should be unique and valid format
            assertThat(transactionId)
                .describedAs("Transaction ID should not be null or empty")
                .isNotNull()
                .isNotEmpty();
                
            assertThat(transactionId)
                .describedAs("Transaction ID should match 16-character COBOL format")
                .hasSize(TestConstants.TRANSACTION_ID_MAX_LENGTH)
                .matches(TRANSACTION_ID_PATTERN);
                
            boolean wasUnique = generatedIds.add(transactionId);
            assertThat(wasUnique)
                .describedAs("Generated transaction ID should be unique: " + transactionId)
                .isTrue();
        }
        
        // Validate total count matches expected
        assertThat(generatedIds)
            .describedAs("Should have generated exactly " + numberOfIds + " unique IDs")
            .hasSize(numberOfIds);
            
        logTestExecution("Successfully generated " + numberOfIds + " unique transaction IDs", null);
    }

    /**
     * Test concurrent ID generation for thread-safety and collision prevention.
     * 
     * This test validates thread-safety requirements by generating transaction IDs
     * concurrently across multiple threads, ensuring no duplicate IDs are produced
     * even under high-volume concurrent access scenarios.
     * 
     * Validates:
     * - Thread-safe ID generation with no race conditions
     * - No duplicate IDs across concurrent threads
     * - Maintains sequential ordering properties under concurrent access
     * - Performance meets or exceeds 10,000 TPS requirement
     * 
     * Performance Target:
     * Based on requirements for 10,000 TPS support, this test validates that
     * concurrent ID generation can sustain high throughput without collisions.
     */
    @Test
    @DisplayName("Concurrent ID generation maintains thread-safety and prevents collisions")
    public void testConcurrentIdGeneration() {
        // Given: High-volume concurrent testing scenario
        final int numberOfThreads = HIGH_VOLUME_THREAD_COUNT;
        final int idsPerThread = TRANSACTIONS_PER_THREAD;
        
        ExecutorService executorService = Executors.newFixedThreadPool(numberOfThreads);
        ConcurrentHashMap<String, String> allGeneratedIds = new ConcurrentHashMap<>();
        List<CompletableFuture<List<String>>> futures = new ArrayList<>();
        CountDownLatch startLatch = new CountDownLatch(1);
        AtomicInteger duplicateCount = new AtomicInteger(0);
        
        long testStartTime = System.currentTimeMillis();
        
        try {
            // When: Multiple threads generate IDs concurrently
            for (int threadIndex = 0; threadIndex < numberOfThreads; threadIndex++) {
                final int currentThreadIndex = threadIndex;
                
                CompletableFuture<List<String>> future = CompletableFuture.supplyAsync(() -> {
                    List<String> threadIds = new ArrayList<>();
                    
                    try {
                        // Wait for all threads to start simultaneously
                        startLatch.await();
                        
                        // Generate IDs for this thread
                        for (int i = 0; i < idsPerThread; i++) {
                            String transactionId = transactionIdGenerator.generateTransactionId();
                            threadIds.add(transactionId);
                            
                            // Check for immediate duplicates using thread-safe map
                            String previousValue = allGeneratedIds.put(transactionId, "Thread-" + currentThreadIndex);
                            if (previousValue != null) {
                                duplicateCount.incrementAndGet();
                                logger.error("Duplicate transaction ID detected: {} from {} and {}", 
                                    transactionId, previousValue, "Thread-" + currentThreadIndex);
                            }
                        }
                        
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                        throw new RuntimeException("Thread interrupted during ID generation", e);
                    }
                    
                    return threadIds;
                }, executorService);
                
                futures.add(future);
            }
            
            // Start all threads simultaneously
            startLatch.countDown();
            
            // Wait for all threads to complete
            List<String> allIds = new ArrayList<>();
            for (CompletableFuture<List<String>> future : futures) {
                List<String> threadIds = future.get(PERFORMANCE_TEST_TIMEOUT_SECONDS, TimeUnit.SECONDS);
                allIds.addAll(threadIds);
            }
            
            long testEndTime = System.currentTimeMillis();
            long totalExecutionTime = testEndTime - testStartTime;
            
            // Then: Validate no duplicates and performance requirements
            assertThat(duplicateCount.get())
                .describedAs("No duplicate transaction IDs should be generated across threads")
                .isEqualTo(0);
                
            assertThat(allIds)
                .describedAs("Should generate expected total number of IDs")
                .hasSize(TOTAL_HIGH_VOLUME_TRANSACTIONS);
                
            // Validate uniqueness using Set conversion
            Set<String> uniqueIds = new HashSet<>(allIds);
            assertThat(uniqueIds)
                .describedAs("All generated IDs should be unique")
                .hasSize(TOTAL_HIGH_VOLUME_TRANSACTIONS);
                
            // Validate performance requirement: 10,000 TPS
            double actualTps = (double) TOTAL_HIGH_VOLUME_TRANSACTIONS / (totalExecutionTime / 1000.0);
            assertThat(actualTps)
                .describedAs("Transaction ID generation should meet or exceed 10,000 TPS requirement")
                .isGreaterThanOrEqualTo(10000.0);
                
            // Validate all IDs match required format
            for (String id : allIds) {
                assertThat(id)
                    .describedAs("All generated IDs should match 16-character COBOL format")
                    .hasSize(TestConstants.TRANSACTION_ID_MAX_LENGTH)
                    .matches(TRANSACTION_ID_PATTERN);
            }
            
            logTestExecution("Concurrent ID generation test completed successfully", totalExecutionTime);
            logger.info("Generated {} IDs across {} threads at {} TPS", 
                TOTAL_HIGH_VOLUME_TRANSACTIONS, numberOfThreads, String.format("%.2f", actualTps));
                
        } catch (Exception e) {
            logger.error("Concurrent ID generation test failed", e);
            throw new RuntimeException("Concurrent testing failed", e);
        } finally {
            executorService.shutdown();
            try {
                if (!executorService.awaitTermination(5, TimeUnit.SECONDS)) {
                    executorService.shutdownNow();
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                executorService.shutdownNow();
            }
        }
    }

    /**
     * Test transaction ID format validation against COBOL VSAM KSDS key requirements.
     * 
     * This test ensures generated transaction IDs conform to the exact format
     * requirements derived from COBOL copybook definitions and VSAM key structure.
     * 
     * Validates:
     * - Exact 16-character length matching COBOL PIC X(16)
     * - Alphanumeric character set compliance
     * - Format consistency across multiple generations
     * - Compatibility with VSAM KSDS key sorting requirements
     * 
     * COBOL Compatibility:
     * Transaction IDs must maintain compatibility with existing COBOL-generated
     * IDs and preserve sorting behavior for VSAM key sequence operations.
     */
    @Test
    @DisplayName("Generated transaction IDs match COBOL VSAM KSDS key format requirements")
    public void testIdFormatValidation() {
        // Given: Multiple ID generation requests for format validation
        final int testSampleSize = 1000;
        
        // When: Generating multiple IDs for format consistency testing
        for (int i = 0; i < testSampleSize; i++) {
            String transactionId = transactionIdGenerator.generateTransactionId();
            
            // Then: Validate exact format requirements
            assertThat(transactionId)
                .describedAs("Transaction ID should not be null")
                .isNotNull();
                
            assertThat(transactionId)
                .describedAs("Transaction ID should have exactly 16 characters")
                .hasSize(TestConstants.TRANSACTION_ID_MAX_LENGTH);
                
            assertThat(transactionId)
                .describedAs("Transaction ID should match alphanumeric pattern for VSAM key compatibility")
                .matches(TRANSACTION_ID_PATTERN);
                
            // Validate no leading/trailing whitespace
            assertThat(transactionId.trim())
                .describedAs("Transaction ID should not contain leading or trailing whitespace")
                .isEqualTo(transactionId);
                
            // Validate character composition for VSAM sorting compatibility
            boolean hasValidCharacters = transactionId.chars()
                .allMatch(c -> Character.isLetterOrDigit(c) && Character.isUpperCase(c) || Character.isDigit(c));
                
            assertThat(hasValidCharacters)
                .describedAs("Transaction ID should contain only uppercase letters and digits")
                .isTrue();
        }
        
        logTestExecution("Format validation completed for " + testSampleSize + " transaction IDs", null);
    }

    /**
     * Test performance under high-volume 10,000 TPS requirement scenarios.
     * 
     * This test validates that transaction ID generation meets performance
     * requirements under sustained high-volume load, ensuring the system
     * can handle peak transaction processing scenarios.
     * 
     * Validates:
     * - Sustained 10,000+ TPS throughput for ID generation
     * - Response time under 200ms threshold per operation
     * - Memory efficiency with minimal garbage collection pressure
     * - CPU utilization remains reasonable under load
     * 
     * Performance Benchmarking:
     * Tests compare against COBOL mainframe performance baselines to ensure
     * the Java implementation meets or exceeds existing system capabilities.
     */
    @Test
    @DisplayName("Transaction ID generation performs at 10,000+ TPS under sustained load")
    public void testPerformanceUnder10kTPS() {
        // Given: High-volume performance testing scenario
        final int warmupIterations = 1000;
        final int performanceTestIterations = 50000; // 5x the 10k TPS requirement for thorough testing
        final long maxAcceptableTimeMs = 5000; // 5 seconds for 50k operations = 10k TPS minimum
        
        // Warmup phase to initialize JVM optimizations
        for (int i = 0; i < warmupIterations; i++) {
            transactionIdGenerator.generateTransactionId();
        }
        
        // When: Performance testing under sustained load
        long startTime = System.nanoTime();
        Set<String> generatedIds = new HashSet<>();
        
        for (int i = 0; i < performanceTestIterations; i++) {
            String transactionId = transactionIdGenerator.generateTransactionId();
            generatedIds.add(transactionId);
            
            // Validate format during performance test
            assertThat(transactionId)
                .hasSize(TestConstants.TRANSACTION_ID_MAX_LENGTH)
                .matches(TRANSACTION_ID_PATTERN);
        }
        
        long endTime = System.nanoTime();
        long totalTimeMs = TimeUnit.NANOSECONDS.toMillis(endTime - startTime);
        
        // Then: Validate performance requirements
        assertThat(totalTimeMs)
            .describedAs("Performance test should complete within acceptable time limit")
            .isLessThanOrEqualTo(maxAcceptableTimeMs);
            
        // Calculate actual TPS
        double actualTps = (double) performanceTestIterations / (totalTimeMs / 1000.0);
        assertThat(actualTps)
            .describedAs("Transaction ID generation should exceed 10,000 TPS requirement")
            .isGreaterThanOrEqualTo(10000.0);
            
        // Validate all IDs are unique even under high-volume generation
        assertThat(generatedIds)
            .describedAs("All generated IDs should be unique under high-volume testing")
            .hasSize(performanceTestIterations);
            
        // Validate average time per operation meets response time requirement
        double avgTimePerOperationMs = (double) totalTimeMs / performanceTestIterations;
        assertThat(avgTimePerOperationMs)
            .describedAs("Average time per ID generation should be well under 200ms threshold")
            .isLessThanOrEqualTo(1.0); // Should be much faster than 200ms
            
        logger.info("Performance test results: {} IDs generated in {}ms at {:.2f} TPS (avg {:.4f}ms per operation)",
            performanceTestIterations, totalTimeMs, actualTps, avgTimePerOperationMs);
            
        logTestExecution("Performance test completed successfully", totalTimeMs);
    }

    /**
     * Test transaction ID collision detection and prevention mechanisms.
     * 
     * This test validates the system's ability to detect and prevent duplicate
     * transaction ID generation, ensuring data integrity and referential consistency
     * in high-volume transaction processing scenarios.
     * 
     * Validates:
     * - Collision detection algorithms identify potential duplicates
     * - Prevention mechanisms ensure no duplicate IDs are generated
     * - Error handling for collision scenarios follows COBOL patterns
     * - Recovery mechanisms maintain system availability
     * 
     * COBOL Error Handling:
     * Matches COBOL behavior where DUPKEY/DUPREC responses trigger appropriate
     * error handling and retry logic for transaction processing.
     */
    @Test
    @DisplayName("ID collision detection prevents duplicate transaction identifiers")
    public void testIdCollisionPrevention() {
        // Given: Collision testing scenario with potential duplicate conditions
        final int numberOfIterations = 10000;
        Set<String> allGeneratedIds = ConcurrentHashMap.newKeySet();
        AtomicInteger collisionAttempts = new AtomicInteger(0);
        AtomicInteger successfulGenerations = new AtomicInteger(0);
        
        // When: Generating IDs with collision monitoring
        ExecutorService executor = Executors.newFixedThreadPool(50);
        List<CompletableFuture<Void>> futures = new ArrayList<>();
        
        for (int i = 0; i < numberOfIterations; i++) {
            CompletableFuture<Void> future = CompletableFuture.runAsync(() -> {
                try {
                    String transactionId = transactionIdGenerator.generateTransactionId();
                    
                    // Attempt to add to set - returns false if duplicate
                    boolean wasUnique = allGeneratedIds.add(transactionId);
                    
                    if (!wasUnique) {
                        collisionAttempts.incrementAndGet();
                        logger.warn("Collision detected for transaction ID: {}", transactionId);
                    } else {
                        successfulGenerations.incrementAndGet();
                    }
                    
                    // Validate format regardless of collision status
                    assertThat(transactionId)
                        .describedAs("Even collision scenarios should produce valid format")
                        .hasSize(TestConstants.TRANSACTION_ID_MAX_LENGTH)
                        .matches(TRANSACTION_ID_PATTERN);
                        
                } catch (Exception e) {
                    logger.error("Error during collision testing", e);
                    throw new RuntimeException(e);
                }
            }, executor);
            
            futures.add(future);
        }
        
        // Wait for all operations to complete
        CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]))
            .orTimeout(PERFORMANCE_TEST_TIMEOUT_SECONDS, TimeUnit.SECONDS)
            .join();
            
        executor.shutdown();
        
        // Then: Validate collision prevention effectiveness
        assertThat(collisionAttempts.get())
            .describedAs("No collision attempts should occur with proper ID generation")
            .isEqualTo(0);
            
        assertThat(successfulGenerations.get())
            .describedAs("All generations should be successful")
            .isEqualTo(numberOfIterations);
            
        assertThat(allGeneratedIds)
            .describedAs("All generated IDs should be unique")
            .hasSize(numberOfIterations);
            
        logTestExecution("Collision prevention test completed", null);
        logger.info("Collision prevention test: {} successful generations, {} collisions detected", 
            successfulGenerations.get(), collisionAttempts.get());
    }

    /**
     * Test sequence number handling and rollover behavior.
     * 
     * This test validates sequence number management including proper increment
     * logic, rollover handling when reaching maximum values, and sequence reset
     * functionality for testing and operational scenarios.
     * 
     * Validates:
     * - Sequential increment follows COBOL ADD 1 TO WS-TRAN-ID-NUM pattern
     * - Rollover handling prevents sequence exhaustion
     * - Reset functionality works correctly for testing scenarios
     * - Sequence state is maintained correctly across operations
     * 
     * COBOL Sequence Logic:
     * Replicates COBOL pattern of reading highest transaction ID using
     * STARTBR/READPREV, then incrementing by 1 for new transaction ID.
     */
    @Test
    @DisplayName("Sequence number handling follows COBOL increment and rollover patterns")
    public void testSequenceNumberHandling() {
        // Given: Sequence testing scenario
        String initialId = transactionIdGenerator.generateTransactionId();
        
        // When: Generating subsequent IDs to test sequence logic
        List<String> sequentialIds = new ArrayList<>();
        sequentialIds.add(initialId);
        
        for (int i = 0; i < 100; i++) {
            String nextId = transactionIdGenerator.generateTransactionId();
            sequentialIds.add(nextId);
        }
        
        // Then: Validate sequential ordering properties
        for (int i = 1; i < sequentialIds.size(); i++) {
            String previousId = sequentialIds.get(i - 1);
            String currentId = sequentialIds.get(i);
            
            // Validate both IDs have proper format
            assertThat(previousId)
                .hasSize(TestConstants.TRANSACTION_ID_MAX_LENGTH)
                .matches(TRANSACTION_ID_PATTERN);
                
            assertThat(currentId)
                .hasSize(TestConstants.TRANSACTION_ID_MAX_LENGTH)
                .matches(TRANSACTION_ID_PATTERN);
                
            // Validate sequential ordering (lexicographic comparison for alphanumeric IDs)
            assertThat(currentId.compareTo(previousId))
                .describedAs("Current ID should be greater than previous ID for proper sequencing")
                .isGreaterThan(0);
        }
        
        // Test sequence reset functionality
        transactionIdGenerator.resetSequence();
        String resetId = transactionIdGenerator.generateTransactionId();
        
        assertThat(resetId)
            .describedAs("Reset sequence should produce valid format")
            .hasSize(TestConstants.TRANSACTION_ID_MAX_LENGTH)
            .matches(TRANSACTION_ID_PATTERN);
            
        logTestExecution("Sequence number handling test completed", null);
        logger.info("Validated sequential ordering for {} generated IDs", sequentialIds.size());
    }

    /**
     * Test thread-safety validation under concurrent high-volume scenarios.
     * 
     * This test specifically focuses on thread-safety mechanisms including
     * synchronization, atomic operations, and concurrent access control to
     * ensure reliable ID generation under production load conditions.
     * 
     * Validates:
     * - Synchronized access to sequence counters
     * - Atomic operations for sequence increment
     * - Thread-local storage where applicable
     * - Lock contention handling under high concurrency
     * 
     * Concurrency Requirements:
     * Must handle 100+ concurrent threads generating IDs simultaneously
     * without producing duplicates or corrupting internal state.
     */
    @Test
    @DisplayName("Thread-safety mechanisms handle high-volume concurrent access")
    public void testThreadSafetyValidation() {
        // Given: Extreme concurrency testing scenario
        final int numberOfThreads = 200; // Stress test with high thread count
        final int operationsPerThread = 50;
        final int totalOperations = numberOfThreads * operationsPerThread;
        
        ExecutorService executorService = Executors.newFixedThreadPool(numberOfThreads);
        CyclicBarrier startBarrier = new CyclicBarrier(numberOfThreads);
        Set<String> allGeneratedIds = ConcurrentHashMap.newKeySet();
        AtomicLong totalGenerationTime = new AtomicLong(0);
        List<CompletableFuture<Void>> futures = new ArrayList<>();
        
        // When: Maximum stress testing with synchronized start
        for (int threadIndex = 0; threadIndex < numberOfThreads; threadIndex++) {
            CompletableFuture<Void> future = CompletableFuture.runAsync(() -> {
                try {
                    // Wait for all threads to start simultaneously
                    startBarrier.await();
                    
                    long threadStartTime = System.nanoTime();
                    
                    // Generate IDs in rapid succession
                    for (int i = 0; i < operationsPerThread; i++) {
                        String transactionId = transactionIdGenerator.generateTransactionId();
                        
                        // Validate immediate thread-safety by checking duplicate insertion
                        boolean wasUnique = allGeneratedIds.add(transactionId);
                        assertThat(wasUnique)
                            .describedAs("Thread-safety failure: duplicate ID generated: " + transactionId)
                            .isTrue();
                            
                        // Validate format under stress
                        assertThat(transactionId)
                            .hasSize(TestConstants.TRANSACTION_ID_MAX_LENGTH)
                            .matches(TRANSACTION_ID_PATTERN);
                    }
                    
                    long threadEndTime = System.nanoTime();
                    totalGenerationTime.addAndGet(threadEndTime - threadStartTime);
                    
                } catch (Exception e) {
                    logger.error("Thread-safety test failure in thread execution", e);
                    throw new RuntimeException("Thread-safety validation failed", e);
                }
            }, executorService);
            
            futures.add(future);
        }
        
        // Wait for all threads to complete with timeout
        long testStartTime = System.currentTimeMillis();
        CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]))
            .orTimeout(PERFORMANCE_TEST_TIMEOUT_SECONDS, TimeUnit.SECONDS)
            .join();
        long testEndTime = System.currentTimeMillis();
        
        executorService.shutdown();
        
        // Then: Validate thread-safety results
        assertThat(allGeneratedIds)
            .describedAs("Thread-safety validation: all IDs should be unique")
            .hasSize(totalOperations);
            
        // Validate performance under thread contention
        long totalTestTimeMs = testEndTime - testStartTime;
        double actualTps = (double) totalOperations / (totalTestTimeMs / 1000.0);
        
        assertThat(actualTps)
            .describedAs("Thread-safety should not significantly impact TPS performance")
            .isGreaterThanOrEqualTo(8000.0); // Allow some performance degradation under extreme concurrency
            
        // Validate average generation time remains acceptable
        double avgGenerationTimeMs = TimeUnit.NANOSECONDS.toMillis(totalGenerationTime.get()) / (double) totalOperations;
        assertThat(avgGenerationTimeMs)
            .describedAs("Average ID generation time should remain under response time threshold")
            .isLessThanOrEqualTo(TestConstants.RESPONSE_TIME_THRESHOLD_MS / 10.0); // Much faster than 200ms
            
        logger.info("Thread-safety test: {} threads, {} operations, {:.2f} TPS, {:.4f}ms avg per operation",
            numberOfThreads, totalOperations, actualTps, avgGenerationTimeMs);
            
        logTestExecution("Thread-safety validation completed", totalTestTimeMs);
    }

    /**
     * Test COBOL compatibility format ensuring generated IDs integrate with existing system.
     * 
     * This test validates that generated transaction IDs maintain full compatibility
     * with existing COBOL-generated IDs and preserve all VSAM key sorting and
     * lookup behaviors required for system integration.
     * 
     * Validates:
     * - Generated IDs sort correctly with existing COBOL IDs
     * - Format compatibility with VSAM KSDS key structures
     * - Character encoding compatibility (EBCDIC considerations)
     * - Lexicographic ordering preservation
     * 
     * COBOL Integration:
     * Ensures Java-generated IDs can be processed by existing COBOL programs
     * and maintain proper key sequence for VSAM file operations.
     */
    @Test
    @DisplayName("Generated IDs maintain COBOL compatibility and VSAM key ordering")
    public void testCobolCompatibilityFormat() {
        // Given: Sample of existing COBOL-style transaction IDs for compatibility testing
        List<String> existingCobolIds = List.of(
            "0000000000000001", // Typical COBOL numeric ID with leading zeros
            "0000000000000999", // Mid-range numeric ID
            "0000000000001000", // Boundary numeric ID
            "0000000000009999", // High numeric ID
            "000000000000ABCD", // Alphanumeric ID format
            "1234567890ABCDEF"  // Mixed alphanumeric format
        );
        
        // When: Generating new IDs that should integrate with existing ones
        List<String> newGeneratedIds = new ArrayList<>();
        for (int i = 0; i < 100; i++) {
            String newId = transactionIdGenerator.generateTransactionId();
            newGeneratedIds.add(newId);
        }
        
        // Then: Validate COBOL compatibility requirements
        for (String newId : newGeneratedIds) {
            // Validate basic format compatibility
            assertThat(newId)
                .describedAs("Generated ID should match COBOL PIC X(16) format")
                .hasSize(16)
                .matches(TRANSACTION_ID_PATTERN);
                
            // Validate character set compatibility (uppercase only)
            assertThat(newId.toUpperCase())
                .describedAs("Generated ID should already be uppercase for COBOL compatibility")
                .isEqualTo(newId);
                
            // Validate no special characters that could interfere with VSAM operations
            boolean hasOnlyValidChars = newId.chars()
                .allMatch(c -> (c >= '0' && c <= '9') || (c >= 'A' && c <= 'Z'));
                
            assertThat(hasOnlyValidChars)
                .describedAs("Generated ID should contain only alphanumeric characters")
                .isTrue();
        }
        
        // Validate sorting compatibility with existing COBOL IDs
        List<String> combinedIds = new ArrayList<>();
        combinedIds.addAll(existingCobolIds);
        combinedIds.addAll(newGeneratedIds);
        
        // Sort using natural string ordering (lexicographic)
        Collections.sort(combinedIds);
        
        // Validate proper interleaving and no sorting anomalies
        for (int i = 1; i < combinedIds.size(); i++) {
            String previous = combinedIds.get(i - 1);
            String current = combinedIds.get(i);
            
            assertThat(current.compareTo(previous))
                .describedAs("Sorted order should be maintained in combined COBOL/Java ID list")
                .isGreaterThanOrEqualTo(0);
        }
        
        // Validate format consistency with COBOL expectations
        assertThat(newGeneratedIds)
            .describedAs("All generated IDs should be unique")
            .doesNotHaveDuplicates();
            
        logTestExecution("COBOL compatibility format validation completed", null);
        logger.info("Validated {} new IDs for COBOL compatibility with {} existing IDs", 
            newGeneratedIds.size(), existingCobolIds.size());
    }

    /**
     * Test proper handling of ID exhaustion scenarios and overflow conditions.
     * 
     * This test validates system behavior when approaching sequence limits,
     * including proper error handling, rollover mechanisms, and graceful
     * degradation to prevent system failures.
     * 
     * Validates:
     * - Sequence exhaustion detection before overflow
     * - Proper error responses for exhaustion scenarios
     * - Rollover mechanisms if implemented
     * - System recovery after sequence reset
     * 
     * Production Resilience:
     * Ensures the system handles edge cases gracefully without causing
     * transaction processing failures or data corruption.
     */
    @Test
    @DisplayName("ID exhaustion scenarios handled gracefully without system failure")
    public void testIdExhaustionScenarios() {
        // Given: Scenario approaching sequence exhaustion
        // Note: In practice, 16-character alphanumeric space is enormous,
        // but we test the mechanisms for handling theoretical exhaustion
        
        // Simulate high sequence numbers near potential overflow
        // This test focuses on the error handling mechanisms
        
        // When: Testing behavior under extreme sequence conditions
        List<String> exhaustionTestIds = new ArrayList<>();
        boolean exhaustionDetected = false;
        Exception lastException = null;
        
        try {
            // Generate IDs until exhaustion detection or reasonable limit
            for (int i = 0; i < 1000; i++) {
                String transactionId = transactionIdGenerator.generateTransactionId();
                exhaustionTestIds.add(transactionId);
                
                // Validate format even under stress conditions
                assertThat(transactionId)
                    .hasSize(TestConstants.TRANSACTION_ID_MAX_LENGTH)
                    .matches(TRANSACTION_ID_PATTERN);
            }
            
        } catch (RuntimeException e) {
            // Expected behavior if exhaustion detection is implemented
            exhaustionDetected = true;
            lastException = e;
            logger.info("Exhaustion detection triggered after {} IDs: {}", 
                exhaustionTestIds.size(), e.getMessage());
        }
        
        // Then: Validate exhaustion handling behavior
        if (exhaustionDetected) {
            // If exhaustion detection is implemented, validate proper error handling
            assertThat(lastException)
                .describedAs("Exhaustion detection should provide meaningful error message")
                .hasMessageContaining("sequence"); // Or similar error indication
                
            assertThat(exhaustionTestIds)
                .describedAs("Should generate some IDs before exhaustion detection")
                .isNotEmpty();
        } else {
            // If no exhaustion detection, ensure all generated IDs are valid and unique
            assertThat(exhaustionTestIds)
                .describedAs("All generated IDs should be unique under exhaustion testing")
                .doesNotHaveDuplicates()
                .hasSize(1000);
        }
        
        // Test sequence reset recovery
        transactionIdGenerator.resetSequence();
        String recoveryId = transactionIdGenerator.generateTransactionId();
        
        assertThat(recoveryId)
            .describedAs("System should recover correctly after sequence reset")
            .hasSize(TestConstants.TRANSACTION_ID_MAX_LENGTH)
            .matches(TRANSACTION_ID_PATTERN);
            
        // Test continued operation after reset
        String followupId = transactionIdGenerator.generateTransactionId();
        assertThat(followupId)
            .describedAs("System should continue normal operation after reset")
            .hasSize(TestConstants.TRANSACTION_ID_MAX_LENGTH)
            .matches(TRANSACTION_ID_PATTERN)
            .isNotEqualTo(recoveryId);
            
        logTestExecution("ID exhaustion scenario handling completed", null);
        logger.info("Exhaustion testing: generated {} IDs, exhaustion detected: {}", 
            exhaustionTestIds.size(), exhaustionDetected);
    }

    /**
     * Helper method to setup time-based mocking for timestamp component testing.
     * 
     * Configures MockedStatic for LocalDateTime to provide controlled timestamp
     * values during testing, enabling deterministic testing of timestamp-based
     * ID components and time-sensitive validation scenarios.
     * 
     * Used by tests that need to validate timestamp components of generated IDs
     * or test time-based sequence behavior.
     */
    private void setupTimeMocks() {
        // Setup fixed timestamp for deterministic testing
        LocalDateTime fixedDateTime = LocalDateTime.of(2024, 1, 15, 10, 30, 45);
        
        // Mock LocalDateTime.now() calls for consistent timestamp testing
        mockedLocalDateTime = Mockito.mockStatic(LocalDateTime.class);
        mockedLocalDateTime.when(LocalDateTime::now).thenReturn(fixedDateTime);
        
        logger.debug("Time mocks configured for deterministic timestamp testing: {}", 
            fixedDateTime.format(DateTimeFormatter.ISO_LOCAL_DATE_TIME));
    }

    /**
     * Parameterized test for validating transaction ID generation with different thread counts.
     * 
     * This test uses JUnit 5 parameterized testing to validate ID generation behavior
     * across various concurrency levels, ensuring consistent performance and correctness
     * from single-threaded to high-concurrency scenarios.
     * 
     * @param threadCount Number of concurrent threads for this test iteration
     */
    @ParameterizedTest(name = "Concurrent ID generation with {0} threads maintains uniqueness")
    @ValueSource(ints = {1, 5, 10, 25, 50, 100})
    @DisplayName("Parameterized concurrent testing validates behavior across thread count variations")
    public void testParameterizedConcurrentGeneration(int threadCount) {
        // Given: Parameterized thread count for scalability testing
        final int idsPerThread = 100;
        final int expectedTotalIds = threadCount * idsPerThread;
        
        ExecutorService executor = Executors.newFixedThreadPool(threadCount);
        CountDownLatch startLatch = new CountDownLatch(1);
        CountDownLatch completeLatch = new CountDownLatch(threadCount);
        Set<String> allIds = ConcurrentHashMap.newKeySet();
        
        // When: Executing with specified thread count
        for (int t = 0; t < threadCount; t++) {
            executor.submit(() -> {
                try {
                    startLatch.await(); // Synchronized start
                    
                    for (int i = 0; i < idsPerThread; i++) {
                        String id = transactionIdGenerator.generateTransactionId();
                        boolean wasUnique = allIds.add(id);
                        
                        assertThat(wasUnique)
                            .describedAs("Each ID should be unique in " + threadCount + " thread scenario")
                            .isTrue();
                            
                        assertThat(id)
                            .hasSize(TestConstants.TRANSACTION_ID_MAX_LENGTH)
                            .matches(TRANSACTION_ID_PATTERN);
                    }
                    
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    throw new RuntimeException(e);
                } finally {
                    completeLatch.countDown();
                }
            });
        }
        
        // Start all threads and wait for completion
        startLatch.countDown();
        
        try {
            boolean completed = completeLatch.await(PERFORMANCE_TEST_TIMEOUT_SECONDS, TimeUnit.SECONDS);
            assertThat(completed)
                .describedAs("All threads should complete within timeout period")
                .isTrue();
                
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            throw new RuntimeException("Test interrupted", e);
        } finally {
            executor.shutdown();
        }
        
        // Then: Validate parameterized test results
        assertThat(allIds)
            .describedAs("Should generate expected number of unique IDs with " + threadCount + " threads")
            .hasSize(expectedTotalIds);
            
        logger.info("Parameterized test with {} threads: {} unique IDs generated", 
            threadCount, allIds.size());
    }

    /**
     * Test formatTransactionId() method for proper ID formatting functionality.
     * 
     * This test validates the formatting utility method that converts raw sequence
     * numbers or timestamp components into properly formatted 16-character
     * transaction IDs matching COBOL PIC X(16) requirements.
     * 
     * Validates:
     * - Proper padding and formatting of numeric inputs
     * - Consistent format output for various input ranges
     * - Error handling for invalid input parameters
     * - COBOL-compatible character encoding and case handling
     */
    @Test
    @DisplayName("formatTransactionId() correctly formats sequence numbers to COBOL format")
    public void testFormatTransactionId() {
        // Given: Various sequence numbers to test formatting logic
        long[] testSequenceNumbers = {
            1L,           // Minimum value
            999L,         // Small value requiring padding
            123456789L,   // Medium value
            999999999999L // Large value approaching limits
        };
        
        // When/Then: Testing formatting for each sequence number
        for (long sequenceNumber : testSequenceNumbers) {
            String formattedId = transactionIdGenerator.formatTransactionId(sequenceNumber);
            
            // Validate format requirements
            assertThat(formattedId)
                .describedAs("Formatted ID should not be null")
                .isNotNull();
                
            assertThat(formattedId)
                .describedAs("Formatted ID should have exactly 16 characters")
                .hasSize(TestConstants.TRANSACTION_ID_MAX_LENGTH);
                
            assertThat(formattedId)
                .describedAs("Formatted ID should match COBOL alphanumeric pattern")
                .matches(TRANSACTION_ID_PATTERN);
                
            // Validate that formatted ID can be parsed back (if applicable)
            assertThat(formattedId)
                .describedAs("Formatted ID should contain the sequence information")
                .containsPattern("[0-9A-Z]+");
        }
        
        // Test edge cases
        assertThatThrownBy(() -> transactionIdGenerator.formatTransactionId(-1L))
            .describedAs("Negative sequence numbers should be rejected")
            .isInstanceOf(IllegalArgumentException.class);
            
        logTestExecution("Format transaction ID testing completed", null);
    }

    /**
     * Test validateTransactionId() method for comprehensive ID validation.
     * 
     * This test validates the validation utility method that verifies transaction
     * ID format compliance, character set requirements, and structural integrity
     * for both newly generated and existing transaction IDs.
     * 
     * Validates:
     * - Format validation for 16-character requirement
     * - Character set validation for COBOL compatibility
     * - Structural validation for VSAM key compliance
     * - Error detection for malformed IDs
     */
    @Test
    @DisplayName("validateTransactionId() correctly validates ID format and compliance")
    public void testValidateTransactionId() {
        // Given: Valid transaction IDs for validation testing
        String validId = transactionIdGenerator.generateTransactionId();
        
        // When/Then: Testing validation of correctly formatted IDs
        boolean isValid = transactionIdGenerator.validateTransactionId(validId);
        assertThat(isValid)
            .describedAs("Generated ID should pass validation")
            .isTrue();
            
        // Test validation of various valid formats
        String[] validTestIds = {
            "0000000000000001", // Numeric with leading zeros
            "1234567890ABCDEF", // Mixed alphanumeric
            "ABCDEFGHIJKLMNOP", // All alphabetic
            "0123456789012345"  // All numeric
        };
        
        for (String testId : validTestIds) {
            boolean result = transactionIdGenerator.validateTransactionId(testId);
            assertThat(result)
                .describedAs("Valid format ID should pass validation: " + testId)
                .isTrue();
        }
        
        // Test validation of invalid formats
        String[] invalidTestIds = {
            null,                    // Null ID
            "",                      // Empty ID
            "123",                   // Too short
            "12345678901234567890", // Too long
            "123456789012345a",      // Contains lowercase
            "123456789012345!",      // Contains special character
            "   1234567890123456",   // Leading whitespace
            "1234567890123456   "    // Trailing whitespace
        };
        
        for (String invalidId : invalidTestIds) {
            if (invalidId == null) {
                assertThatThrownBy(() -> transactionIdGenerator.validateTransactionId(null))
                    .describedAs("Null ID should be rejected with appropriate exception")
                    .isInstanceOf(IllegalArgumentException.class);
            } else {
                boolean result = transactionIdGenerator.validateTransactionId(invalidId);
                assertThat(result)
                    .describedAs("Invalid format ID should fail validation: '" + invalidId + "'")
                    .isFalse();
            }
        }
        
        logTestExecution("Validate transaction ID testing completed", null);
    }

    /**
     * Test repeated ID generation to validate consistency over time.
     * 
     * This repeated test validates that ID generation maintains consistency,
     * uniqueness, and performance characteristics across multiple test runs,
     * ensuring reliable behavior in production scenarios.
     */
    @RepeatedTest(value = 10, name = "Repeated ID generation test {currentRepetition}/{totalRepetitions}")
    @DisplayName("Repeated testing validates consistent ID generation behavior")
    public void testRepeatedIdGeneration() {
        // Given: Repeated execution scenario
        final int idsPerRepetition = 100;
        Set<String> repetitionIds = new HashSet<>();
        
        // When: Generating IDs in this repetition
        for (int i = 0; i < idsPerRepetition; i++) {
            String id = transactionIdGenerator.generateTransactionId();
            repetitionIds.add(id);
            
            // Validate format in each repetition
            assertThat(id)
                .hasSize(TestConstants.TRANSACTION_ID_MAX_LENGTH)
                .matches(TRANSACTION_ID_PATTERN);
        }
        
        // Then: Validate repetition results
        assertThat(repetitionIds)
            .describedAs("Each repetition should generate unique IDs")
            .hasSize(idsPerRepetition);
            
        logger.debug("Repetition generated {} unique IDs", repetitionIds.size());
    }
}
