# =============================================================================
# Gatling Performance Test Scenarios Configuration
# CardDemo Mainframe-to-Cloud Migration Performance Testing
# =============================================================================
#
# Purpose: Define performance test scenarios, injection profiles, protocol 
# configurations, and assertion criteria for validating card authorization, 
# transaction processing, and batch job performance against mainframe baseline.
#
# Critical Requirements:
# - Maintain sub-200ms response times (95th percentile) per Section 0.5.1
# - Support 10,000 TPS load testing as specified in requirements
# - Validate performance meets or exceeds mainframe benchmarks
# - Comprehensive metrics collection for COBOL-Java parity validation
#
# =============================================================================

# -----------------------------------------------------------------------------
# GATLING GLOBAL CONFIGURATION
# -----------------------------------------------------------------------------
gatling {
  core {
    # Simulation class configuration
    simulationClass = "com.carddemo.performance.CardDemoLoadTestSuite"
    
    # Output directory for test results
    outputDirectoryBaseName = "carddemo-performance"
    
    # Enable detailed metrics collection
    extract {
      regex {
        cacheMaxCapacity = 1000
      }
      xpath {
        cacheMaxCapacity = 1000
      }
      jsonPath {
        cacheMaxCapacity = 1000
      }
    }
  }
  
  # HTTP protocol configuration for Spring Boot REST APIs
  http {
    # Connection pool settings for high-load testing
    pooledConnectionIdleTimeout = 60000
    pooledConnectionTtl = 300000
    maxRetry = 3
    
    # Request/response configuration
    requestTimeout = 5000
    connectTimeout = 5000
    readTimeout = 5000
    
    # Enable detailed HTTP logging for debugging
    enableHttp2 = false
    
    # User agent for load testing identification
    userAgentHeader = "Gatling-CardDemo-LoadTest/1.0"
  }
  
  # Data feed configuration for test data management
  data {
    writers = "console, file, graphite"
    console {
      light = false
    }
    file {
      bufferSize = 8192
    }
  }
}

# -----------------------------------------------------------------------------
# SIMULATION INJECTION PROFILES
# -----------------------------------------------------------------------------
injection {
  # Base load testing profile - validates normal operations
  baseLoad {
    # Gradual ramp-up to 1000 concurrent users over 2 minutes
    rampUsers = 1000
    rampDuration = "2 minutes"
    
    # Sustain load for 10 minutes to validate stability
    constantUsers = 1000
    constantDuration = "10 minutes"
  }
  
  # High load testing profile - validates 10,000 TPS requirement
  highLoad {
    # Rapid scaling to 10,000 users to test peak capacity
    rampUsers = 10000
    rampDuration = "5 minutes"
    
    # Sustain peak load for 15 minutes
    constantUsers = 10000
    constantDuration = "15 minutes"
    
    # Gradual ramp-down to prevent system shock
    rampDownUsers = 0
    rampDownDuration = "3 minutes"
  }
  
  # Spike testing profile - validates system resilience
  spikeLoad {
    # Immediate spike to 5000 users
    atOnceUsers = 5000
    
    # Brief sustained load
    constantUsers = 5000
    constantDuration = "2 minutes"
  }
  
  # Stress testing profile - determines system breaking point
  stressLoad {
    # Progressive load increase beyond normal capacity
    rampUsers = 15000
    rampDuration = "10 minutes"
    
    # Sustain stress load to identify failure points
    constantUsers = 15000
    constantDuration = "5 minutes"
  }
}

# -----------------------------------------------------------------------------
# HTTP PROTOCOL CONFIGURATION
# -----------------------------------------------------------------------------
protocol {
  http {
    # Base URL for CardDemo Spring Boot application
    baseUrl = "http://localhost:8080"
    
    # Standard headers for all requests
    headers {
      "Accept" = "application/json"
      "Content-Type" = "application/json"
      "User-Agent" = "Gatling-CardDemo-LoadTest/1.0"
      "Cache-Control" = "no-cache"
    }
    
    # Authentication headers (will be dynamically set per scenario)
    # Authorization header added after sign-on simulation
    
    # Connection keep-alive for performance
    connectionHeader = "keep-alive"
    
    # SSL/TLS configuration for HTTPS endpoints
    https {
      trustStore {
        type = "JKS"
        file = "src/test/resources/ssl/carddemo-truststore.jks"
        password = "changeit"
      }
    }
  }
}

# -----------------------------------------------------------------------------
# TRANSACTION SCENARIO DEFINITIONS
# Based on COBOL programs: COTRN00C, COACTVWC, COBIL00C
# -----------------------------------------------------------------------------
scenarios {
  
  # Sign-On Transaction Scenario (CC00 - COSGN00C equivalent)
  signOn {
    name = "CardDemo Sign-On Transaction"
    description = "User authentication and menu access - Spring Security validation"
    
    # Request configuration
    request {
      url = "/api/auth/signin"
      method = "POST"
      
      # Test data for authentication
      body = """{
        "userId": "TESTUSER",
        "password": "password123",
        "transactionCode": "CC00"
      }"""
      
      # Response validation
      checks = [
        "status.is(200)",
        "jsonPath('$.authenticated').is('true')",
        "jsonPath('$.userId').is('TESTUSER')",
        "responseTimeInMillis.lte(200)"
      ]
    }
    
    # Performance thresholds
    assertions {
      responseTime {
        mean = 100
        p95 = 200
        max = 500
      }
      successfulRequests {
        percent = 99.5
      }
    }
  }
  
  # Transaction List Scenario (CT00 - COTRN00C equivalent)
  transactionList {
    name = "Transaction List Retrieval"
    description = "Paginated transaction history with cursor operations - VSAM equivalent"
    
    # Request configuration
    request {
      url = "/api/transactions/list"
      method = "GET"
      
      # Query parameters for pagination (VSAM READNEXT equivalent)
      queryParams = {
        "accountId" = "#{accountId}"
        "pageSize" = "10"
        "startKey" = "#{transactionId}"
      }
      
      # Response validation
      checks = [
        "status.is(200)",
        "jsonPath('$.transactions').exists",
        "jsonPath('$.pagination.hasNextPage').exists",
        "jsonPath('$.transactions[*].transactionId').exists",
        "responseTimeInMillis.lte(200)"
      ]
    }
    
    # Performance thresholds
    assertions {
      responseTime {
        mean = 75
        p95 = 150
        max = 300
      }
      successfulRequests {
        percent = 99.8
      }
    }
  }
  
  # Account View Scenario (CAVW - COACTVWC equivalent) 
  accountView {
    name = "Account Details Retrieval"
    description = "Account information display with cross-reference lookup"
    
    # Request configuration
    request {
      url = "/api/accounts/#{accountId}/details"
      method = "GET"
      
      # Response validation - ensure complete account data
      checks = [
        "status.is(200)",
        "jsonPath('$.accountId').exists",
        "jsonPath('$.customerId').exists", 
        "jsonPath('$.currentBalance').exists",
        "jsonPath('$.accountStatus').exists",
        "jsonPath('$.cardInformation').exists",
        "responseTimeInMillis.lte(200)"
      ]
    }
    
    # Performance thresholds
    assertions {
      responseTime {
        mean = 80
        p95 = 160
        max = 350
      }
      successfulRequests {
        percent = 99.9
      }
    }
  }
  
  # Bill Payment Scenario (CB00 - COBIL00C equivalent)
  billPayment {
    name = "Bill Payment Processing"
    description = "Account balance update and transaction creation - financial precision validation"
    
    # Request configuration
    request {
      url = "/api/payments/billpay"
      method = "POST"
      
      # Test data for payment processing
      body = """{
        "accountId": "#{accountId}",
        "paymentAmount": "#{paymentAmount}",
        "confirmPayment": "Y",
        "transactionSource": "ONLINE"
      }"""
      
      # Response validation - ensure payment accuracy
      checks = [
        "status.is(200)",
        "jsonPath('$.transactionId').exists",
        "jsonPath('$.newBalance').exists",
        "jsonPath('$.paymentStatus').is('COMPLETED')",
        "jsonPath('$.processingTime').exists",
        "responseTimeInMillis.lte(200)"
      ]
    }
    
    # Performance thresholds
    assertions {
      responseTime {
        mean = 120
        p95 = 200
        max = 400
      }
      successfulRequests {
        percent = 99.95
      }
      # Critical: Financial transactions must maintain precision
      responseBytes {
        mean = 500  # Approximate JSON response size
      }
    }
  }
  
  # Card Authorization Scenario (High-frequency transaction)
  cardAuthorization {
    name = "Card Authorization Processing"
    description = "Real-time card authorization with fraud detection"
    
    # Request configuration
    request {
      url = "/api/cards/authorize"
      method = "POST"
      
      # Test data for card authorization
      body = """{
        "cardNumber": "#{cardNumber}",
        "amount": "#{transactionAmount}",
        "merchantId": "#{merchantId}",
        "transactionType": "PURCHASE"
      }"""
      
      # Response validation
      checks = [
        "status.is(200)",
        "jsonPath('$.authorizationCode').exists",
        "jsonPath('$.responseCode').in('00', '01')",
        "jsonPath('$.processingTime').lte(200)",
        "responseTimeInMillis.lte(200)"
      ]
    }
    
    # Strict performance requirements for real-time processing
    assertions {
      responseTime {
        mean = 50
        p95 = 150
        max = 200
      }
      successfulRequests {
        percent = 99.99
      }
    }
  }
}

# -----------------------------------------------------------------------------
# TEST DATA CONFIGURATION
# -----------------------------------------------------------------------------
testData {
  # Account test data for parameterized testing
  accounts {
    file = "src/test/resources/performance/test-accounts.csv"
    circular = true
    eager = false
  }
  
  # Transaction test data
  transactions {
    file = "src/test/resources/performance/test-transactions.csv"
    circular = true
    eager = false
  }
  
  # Card numbers for authorization testing
  cards {
    file = "src/test/resources/performance/test-cards.csv"
    circular = true
    eager = false
  }
  
  # Merchant data for transaction processing
  merchants {
    file = "src/test/resources/performance/test-merchants.csv"
    circular = true
    eager = false
  }
  
  # Synthetic data generation for high-volume testing
  synthetic {
    # Generate account IDs in mainframe format (11 digits)
    accountIdPattern = "#{randomLong(10000000000L, 99999999999L)}"
    
    # Generate transaction amounts (precision matching COBOL COMP-3)
    transactionAmountPattern = "#{randomDouble(1.00, 999.99)}"
    
    # Generate payment amounts for bill pay testing
    paymentAmountPattern = "#{randomDouble(10.00, 5000.00)}"
    
    # Generate card numbers (16 digits, test format)
    cardNumberPattern = "4532#{randomLong(100000000000L, 999999999999L)}"
    
    # Generate merchant IDs
    merchantIdPattern = "MERCH#{randomInt(1000, 9999)}"
  }
}

# -----------------------------------------------------------------------------
# PERFORMANCE MONITORING CONFIGURATION
# -----------------------------------------------------------------------------
monitoring {
  # Micrometer integration for Spring Boot metrics
  micrometer {
    enabled = true
    registryUrl = "http://localhost:8080/actuator/prometheus"
    interval = "5s"
    
    # Custom metrics to collect
    metrics = [
      "http_server_requests_seconds",
      "jvm_memory_used_bytes",
      "jvm_gc_pause_seconds",
      "spring_data_repository_invocations_seconds",
      "hikaricp_connections_active"
    ]
  }
  
  # System resource monitoring
  system {
    enabled = true
    interval = "10s"
    
    # Metrics to capture
    metrics = [
      "cpu_usage_percent",
      "memory_usage_percent", 
      "disk_io_operations",
      "network_bytes_transmitted"
    ]
  }
  
  # Database performance monitoring
  database {
    enabled = true
    url = "jdbc:postgresql://localhost:5432/carddemo"
    interval = "15s"
    
    # PostgreSQL specific metrics
    queries = [
      "SELECT pg_stat_get_db_numbackends(oid) as active_connections FROM pg_database WHERE datname='carddemo'",
      "SELECT query, mean_exec_time, calls FROM pg_stat_statements ORDER BY mean_exec_time DESC LIMIT 10"
    ]
  }
}

# -----------------------------------------------------------------------------
# ASSERTION CRITERIA AND THRESHOLDS
# -----------------------------------------------------------------------------
assertions {
  # Global performance requirements
  global {
    # Response time requirements (matching mainframe baseline)
    responseTime {
      mean = 100      # Average response time target
      p95 = 200       # 95th percentile must be under 200ms (critical requirement)
      p99 = 300       # 99th percentile maximum
      max = 500       # Absolute maximum response time
    }
    
    # Throughput requirements
    throughput {
      min = 8000      # Minimum TPS under load
      target = 10000  # Target TPS (requirement specification)
      max = 12000     # Peak capacity validation
    }
    
    # Success rate requirements
    successfulRequests {
      percent = 99.5  # Minimum success rate
    }
    
    # Error rate thresholds
    failedRequests {
      percent = 0.5   # Maximum failure rate
    }
  }
  
  # Transaction-specific thresholds
  transactionSpecific {
    # Financial transactions (bill payment, authorization)
    financial {
      responseTime {
        mean = 75
        p95 = 150
        max = 200
      }
      successfulRequests {
        percent = 99.95  # Higher requirement for financial accuracy
      }
    }
    
    # Query transactions (account view, transaction list)
    query {
      responseTime {
        mean = 50
        p95 = 100
        max = 200
      }
      successfulRequests {
        percent = 99.8
      }
    }
    
    # Authentication transactions
    authentication {
      responseTime {
        mean = 80
        p95 = 160
        max = 250
      }
      successfulRequests {
        percent = 99.9
      }
    }
  }
}

# -----------------------------------------------------------------------------
# REPORTING CONFIGURATION
# -----------------------------------------------------------------------------
reports {
  # HTML report generation
  html {
    enabled = true
    outputDirectory = "target/gatling/results"
    
    # Include detailed breakdown by scenario
    includeScenarioBreakdown = true
    includeRequestBreakdown = true
    includeGroupBreakdown = true
  }
  
  # JSON report for CI/CD integration
  json {
    enabled = true
    outputFile = "target/gatling/results/performance-results.json"
    
    # Include raw data for trend analysis
    includeRawData = true
  }
  
  # JUnit XML for test reporting integration
  junit {
    enabled = true
    outputFile = "target/gatling/results/TEST-performance.xml"
  }
  
  # CSV export for external analysis
  csv {
    enabled = true
    outputDirectory = "target/gatling/results/csv"
    
    # Export detailed metrics
    includeTimestamps = true
    includeMetrics = true
  }
  
  # Prometheus metrics export
  prometheus {
    enabled = true
    endpoint = "http://localhost:9090/api/v1/write"
    
    # Labels for metric identification
    labels = {
      "application" = "carddemo"
      "environment" = "performance-test"
      "version" = "#{env.BUILD_VERSION}"
    }
  }
}

# -----------------------------------------------------------------------------
# ADVANCED CONFIGURATION
# -----------------------------------------------------------------------------
advanced {
  # Connection pooling optimization
  connectionPool {
    maxConnectionsPerHost = 50
    maxConnections = 1000
    connectionTimeout = 5000
    requestTimeout = 10000
    
    # Enable HTTP/2 if supported
    enableHttp2 = false
    
    # TCP configuration
    tcpNoDelay = true
    soKeepAlive = true
    soReuseAddr = true
  }
  
  # Memory optimization for high-load testing
  memory {
    # JVM heap settings for Gatling
    initialHeapSize = "2g"
    maxHeapSize = "8g"
    
    # GC optimization
    gcSettings = "-XX:+UseG1GC -XX:MaxGCPauseMillis=200"
  }
  
  # Logging configuration
  logging {
    level = "INFO"
    
    # Performance logging
    performanceLogging = true
    
    # Request/response logging (enable for debugging)
    httpLogging = false
    
    # Custom logger for financial precision validation
    precisionLogger = "com.carddemo.performance.PrecisionValidator"
  }
  
  # Session management
  session {
    # Enable session persistence for user journey testing
    enableSession = true
    
    # Session timeout (matching application settings)
    sessionTimeout = "30 minutes"
    
    # Cookie handling
    enableCookies = true
    cookieStore = "shared"
  }
}

# -----------------------------------------------------------------------------
# ENVIRONMENT-SPECIFIC OVERRIDES
# -----------------------------------------------------------------------------
environments {
  # Development environment
  dev {
    protocol.http.baseUrl = "http://localhost:8080"
    injection.baseLoad.constantUsers = 100
    injection.highLoad.constantUsers = 1000
    monitoring.micrometer.registryUrl = "http://localhost:8080/actuator/prometheus"
  }
  
  # Integration test environment
  integration {
    protocol.http.baseUrl = "http://carddemo-integration.k8s.local"
    injection.baseLoad.constantUsers = 500
    injection.highLoad.constantUsers = 5000
    monitoring.micrometer.registryUrl = "http://carddemo-integration.k8s.local/actuator/prometheus"
  }
  
  # Performance test environment  
  performance {
    protocol.http.baseUrl = "http://carddemo-perf.k8s.local"
    injection.baseLoad.constantUsers = 1000
    injection.highLoad.constantUsers = 10000
    monitoring.micrometer.registryUrl = "http://carddemo-perf.k8s.local/actuator/prometheus"
    
    # Enable stress testing in performance environment
    injection.stressLoad.enabled = true
  }
  
  # Production-like validation environment
  validation {
    protocol.http.baseUrl = "https://carddemo-validation.company.com"
    protocol.https.enabled = true
    injection.baseLoad.constantUsers = 2000
    injection.highLoad.constantUsers = 15000
    
    # Strict assertion criteria for production validation
    assertions.global.successfulRequests.percent = 99.95
    assertions.global.responseTime.p95 = 150
  }
}

# -----------------------------------------------------------------------------
# INTEGRATION CONFIGURATION
# -----------------------------------------------------------------------------
integration {
  # CI/CD pipeline integration
  cicd {
    # Jenkins integration
    jenkins {
      enabled = true
      
      # Publish results to Jenkins
      publishResults = true
      publishArtifacts = ["target/gatling/results/**/*"]
      
      # Quality gates for pipeline
      qualityGates = {
        responseTimeP95 = 200
        successRate = 99.5
        errorRate = 0.5
      }
    }
    
    # GitLab CI integration
    gitlab {
      enabled = true
      
      # Performance metrics as GitLab job artifacts
      artifacts = ["target/gatling/results/performance-results.json"]
      
      # Custom metrics for GitLab
      customMetrics = {
        "gatling_response_time_p95" = "${assertions.global.responseTime.p95}"
        "gatling_success_rate" = "${assertions.global.successfulRequests.percent}"
      }
    }
  }
  
  # Monitoring platform integration
  monitoring {
    # Grafana dashboard integration
    grafana {
      enabled = true
      dashboardUrl = "http://grafana.company.com/d/carddemo-performance"
      
      # Auto-create annotations for test runs
      createAnnotations = true
      annotationTags = ["performance-test", "gatling", "carddemo"]
    }
    
    # Slack notifications
    notifications {
      slack {
        enabled = true
        webhookUrl = "${env.SLACK_WEBHOOK_URL}"
        
        # Notification conditions
        notifyOnFailure = true
        notifyOnThresholdBreach = true
        
        # Message templates
        failureMessage = "🚨 CardDemo Performance Test Failed - Response time: ${responseTime.p95}ms"
        successMessage = "✅ CardDemo Performance Test Passed - TPS: ${throughput.actual}"
      }
    }
  }
}

# =============================================================================
# END OF CONFIGURATION
# =============================================================================