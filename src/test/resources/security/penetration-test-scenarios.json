{
  "metadata": {
    "version": "1.0.0",
    "description": "Comprehensive penetration testing scenarios for CardDemo Spring Security implementation validation",
    "targetArchitecture": "Spring Boot microservices with JWT authentication and PostgreSQL database",
    "complianceFrameworks": ["PCI DSS 4.0", "SOX 404", "OWASP Top 10 2021"],
    "lastUpdated": "2024-01-15",
    "author": "CardDemo Security Testing Team"
  },

  "PenetrationTestScenarios": {
    "description": "Primary penetration testing scenario collection providing comprehensive security validation through simulated attacks, vulnerability exploitation attempts, and security control effectiveness testing",
    
    "sqlInjectionAttackScenarios": {
      "description": "SQL injection vulnerability testing scenarios targeting PostgreSQL database interactions through Spring Data JPA repositories",
      "testEnvironment": {
        "targetEndpoints": [
          "/api/auth/login",
          "/api/cavw/accounts/{accountId}",
          "/api/accounts/{accountId}",
          "/api/admin/users",
          "/api/admin/users/{userId}"
        ],
        "databaseLayer": "PostgreSQL 15+ with Spring Data JPA",
        "securityControls": ["Parameterized queries", "Input validation", "SQL injection prevention"]
      },
      
      "attackVectors": [
        {
          "scenarioId": "SQL_INJ_001",
          "name": "Authentication Bypass via SQL Injection",
          "description": "Attempt to bypass authentication by injecting SQL into login credentials",
          "targetEndpoint": "/api/auth/login",
          "httpMethod": "POST",
          "payloadType": "JSON",
          "attackPayload": {
            "username": "admin' OR '1'='1' --",
            "password": "password' OR '1'='1' --"
          },
          "expectedResult": {
            "responseCode": 401,
            "securityMeasure": "BCrypt password hashing prevents SQL injection in credentials",
            "validationCriteria": "Authentication should fail with proper error handling"
          },
          "validationSteps": [
            "Send malicious SQL injection payload in login request",
            "Verify authentication fails with 401 Unauthorized",
            "Confirm no SQL errors exposed in response",
            "Validate proper error logging without sensitive information leakage"
          ]
        },
        {
          "scenarioId": "SQL_INJ_002", 
          "name": "Account ID Parameter SQL Injection",
          "description": "Attempt SQL injection through account ID path parameter",
          "targetEndpoint": "/api/cavw/accounts/{accountId}",
          "httpMethod": "GET",
          "authRequired": true,
          "attackPayload": {
            "pathParameter": "12345'; DROP TABLE accounts; --"
          },
          "expectedResult": {
            "responseCode": 400,
            "securityMeasure": "Spring Data JPA parameterized queries prevent injection",
            "validationCriteria": "Request should fail with bad request error"
          },
          "validationSteps": [
            "Authenticate with valid JWT token",
            "Send request with SQL injection in accountId path parameter",
            "Verify 400 Bad Request response with proper validation error",
            "Confirm database integrity remains intact"
          ]
        },
        {
          "scenarioId": "SQL_INJ_003",
          "name": "User Search SQL Injection",
          "description": "Test SQL injection via user search parameters in admin endpoints",
          "targetEndpoint": "/api/admin/users",
          "httpMethod": "GET",
          "authRequired": true,
          "requiredRole": "ROLE_ADMIN",
          "attackPayload": {
            "queryParameters": {
              "search": "admin' UNION SELECT password_hash FROM users WHERE '1'='1"
            }
          },
          "expectedResult": {
            "responseCode": 400,
            "securityMeasure": "Input validation and parameterized queries prevent data exfiltration",
            "validationCriteria": "Search should fail with validation error"
          },
          "validationSteps": [
            "Authenticate with admin role JWT token", 
            "Send user search request with UNION-based SQL injection",
            "Verify proper input validation prevents malicious query execution",
            "Confirm sensitive data is not exposed in error responses"
          ]
        }
      ]
    },

    "xssVulnerabilityTesting": {
      "description": "Cross-Site Scripting (XSS) vulnerability testing scenarios for React frontend and Spring Boot API responses",
      "testEnvironment": {
        "frontendFramework": "React 18+ with Material-UI components",
        "securityControls": ["Content Security Policy", "Output encoding", "Input sanitization"],
        "targetComponents": ["LoginComponent.jsx", "MainMenuComponent.jsx", "AccountViewComponent.jsx"]
      },

      "attackVectors": [
        {
          "scenarioId": "XSS_001",
          "name": "Stored XSS in User Profile Data",
          "description": "Attempt to store malicious JavaScript in user profile fields",
          "targetEndpoint": "/api/admin/users/{userId}",
          "httpMethod": "PUT",
          "authRequired": true,
          "requiredRole": "ROLE_ADMIN",
          "attackPayload": {
            "userId": "12345",
            "firstName": "<script>alert('XSS')</script>",
            "lastName": "User<img src=x onerror=alert('XSS')>",
            "userType": "U"
          },
          "expectedResult": {
            "responseCode": 400,
            "securityMeasure": "Input validation and sanitization prevent XSS payload storage",
            "validationCriteria": "Malicious scripts should be rejected or sanitized"
          },
          "validationSteps": [
            "Authenticate with admin role JWT token",
            "Send user update request with XSS payloads in name fields",
            "Verify input validation rejects or sanitizes malicious content",
            "Confirm stored data does not contain executable scripts"
          ]
        },
        {
          "scenarioId": "XSS_002",
          "name": "Reflected XSS in Error Messages",
          "description": "Test for reflected XSS in API error responses",
          "targetEndpoint": "/api/cavw/accounts/{accountId}",
          "httpMethod": "GET", 
          "authRequired": true,
          "attackPayload": {
            "pathParameter": "<script>alert('Reflected XSS')</script>"
          },
          "expectedResult": {
            "responseCode": 400,
            "securityMeasure": "Output encoding prevents XSS in error messages",
            "validationCriteria": "Error response should not contain unescaped script tags"
          },
          "validationSteps": [
            "Send request with XSS payload in path parameter",
            "Verify error response properly encodes/escapes the input",
            "Confirm no executable JavaScript in response headers or body",
            "Validate Content-Security-Policy header prevents inline script execution"
          ]
        },
        {
          "scenarioId": "XSS_003",
          "name": "DOM-based XSS in React Components",
          "description": "Test for DOM-based XSS vulnerabilities in React frontend components",
          "targetComponent": "AccountViewComponent.jsx",
          "attackVector": "Client-side rendering",
          "attackPayload": {
            "accountData": {
              "accountName": "Test Account<script>alert('DOM XSS')</script>",
              "accountDescription": "Description<img src=x onerror=alert('XSS')>"
            }
          },
          "expectedResult": {
            "securityMeasure": "React's built-in XSS protection and proper output encoding",
            "validationCriteria": "Malicious scripts should not execute in DOM"
          },
          "validationSteps": [
            "Load AccountViewComponent with malicious account data",
            "Verify React properly escapes dynamic content",
            "Confirm no JavaScript execution occurs from injected payloads",
            "Validate CSP headers prevent inline script execution"
          ]
        }
      ]
    },

    "csrfAttackSimulation": {
      "description": "Cross-Site Request Forgery (CSRF) attack simulation testing Spring Security CSRF protection mechanisms",
      "testEnvironment": {
        "csrfProtection": "CsrfSecurityConfig with CookieCsrfTokenRepository",
        "tokenValidation": "X-CSRF-TOKEN header and _csrf parameter support",
        "securityControls": ["CSRF token validation", "SameSite cookie attributes", "Referrer validation"]
      },

      "attackVectors": [
        {
          "scenarioId": "CSRF_001",
          "name": "Account Update without CSRF Token",
          "description": "Attempt to update account information without valid CSRF token",
          "targetEndpoint": "/api/accounts/{accountId}",
          "httpMethod": "PUT",
          "authRequired": true,
          "attackMethod": "Missing CSRF token",
          "attackPayload": {
            "headers": {
              "Authorization": "Bearer valid_jwt_token",
              "Content-Type": "application/json"
            },
            "body": {
              "accountId": "12345678901",
              "accountName": "Malicious Update",
              "accountStatus": "A"
            }
          },
          "expectedResult": {
            "responseCode": 403,
            "securityMeasure": "CSRF protection blocks requests without valid token",
            "validationCriteria": "Request should be rejected with CSRF protection violation"
          },
          "validationSteps": [
            "Authenticate and obtain valid JWT token",
            "Send account update request without X-CSRF-TOKEN header",
            "Verify 403 Forbidden response with CSRF violation message",
            "Confirm account data remains unchanged"
          ]
        },
        {
          "scenarioId": "CSRF_002",
          "name": "Cross-Origin CSRF Attack Simulation",
          "description": "Simulate CSRF attack from malicious external website",
          "targetEndpoint": "/api/admin/users",
          "httpMethod": "POST",
          "authRequired": true,
          "requiredRole": "ROLE_ADMIN",
          "attackMethod": "Cross-origin form submission",
          "attackPayload": {
            "origin": "https://malicious-site.com",
            "headers": {
              "Authorization": "Bearer valid_admin_token",
              "Content-Type": "application/json",
              "Origin": "https://malicious-site.com",
              "Referer": "https://malicious-site.com/attack.html"
            },
            "body": {
              "userId": "MALICIOUS",
              "firstName": "Malicious",
              "lastName": "User",
              "userType": "A"
            }
          },
          "expectedResult": {
            "responseCode": 403,
            "securityMeasure": "CORS policy and CSRF protection prevent cross-origin attacks",
            "validationCriteria": "Request should be blocked by CORS and CSRF protection"
          },
          "validationSteps": [
            "Simulate request from external malicious domain",
            "Include valid authentication but no CSRF token",
            "Verify CORS policy blocks the cross-origin request",
            "Confirm CSRF protection provides additional security layer"
          ]
        },
        {
          "scenarioId": "CSRF_003",
          "name": "CSRF Token Tampering Attack",
          "description": "Test CSRF protection against token tampering and replay attacks",
          "targetEndpoint": "/api/accounts/{accountId}",
          "httpMethod": "PUT",
          "authRequired": true,
          "attackMethod": "Invalid/tampered CSRF token",
          "attackPayload": {
            "headers": {
              "Authorization": "Bearer valid_jwt_token",
              "Content-Type": "application/json",
              "X-CSRF-TOKEN": "tampered-csrf-token-value"
            },
            "body": {
              "accountId": "12345678901",
              "accountStatus": "I"
            }
          },
          "expectedResult": {
            "responseCode": 403,
            "securityMeasure": "CSRF token validation prevents tampering attacks",
            "validationCriteria": "Tampered token should be rejected"
          },
          "validationSteps": [
            "Obtain valid CSRF token from /api/csrf/token endpoint",
            "Modify the token value before sending request",
            "Verify server rejects the tampered token",
            "Confirm proper error response without token information leakage"
          ]
        }
      ]
    },

    "authenticationBypassAttempts": {
      "description": "Authentication bypass testing scenarios targeting Spring Security JWT authentication mechanisms",
      "testEnvironment": {
        "authenticationService": "AuthenticationService.java with JWT token generation",
        "jwtConfiguration": "Spring Security OAuth2 Resource Server with HS256 algorithm",
        "securityControls": ["JWT signature validation", "Token expiration", "User credential verification"]
      },

      "attackVectors": [
        {
          "scenarioId": "AUTH_BYPASS_001",
          "name": "JWT Signature Manipulation",
          "description": "Attempt to bypass authentication by manipulating JWT token signature",
          "targetEndpoint": "/api/cavw/accounts/12345678901",
          "httpMethod": "GET",
          "attackMethod": "JWT signature tampering",
          "attackPayload": {
            "headers": {
              "Authorization": "Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoiVVNFUjAwMSIsInVzZXJfdHlwZSI6IlUiLCJyb2xlcyI6WyJST0xFX0FETUlOIl0sInNlc3Npb25faWQiOiJ0YW1wZXJlZC1zZXNzaW9uIiwic3ViIjoiVVNFUjAwMSIsImlhdCI6MTcwNTY2MDgwMCwiZXhwIjoxNzA1NjYyNjAwfQ.TAMPERED_SIGNATURE_FOR_TESTING"
            }
          },
          "expectedResult": {
            "responseCode": 401,
            "securityMeasure": "Spring Security JWT signature validation prevents token tampering",
            "validationCriteria": "Invalid signature should result in authentication failure"
          },
          "validationSteps": [
            "Create JWT token with elevated privileges in payload",
            "Modify signature to simulate tampering attack",
            "Send request with tampered token",
            "Verify authentication fails with 401 Unauthorized",
            "Confirm no access to protected resources"
          ]
        },
        {
          "scenarioId": "AUTH_BYPASS_002",
          "name": "Algorithm Confusion Attack",
          "description": "Test JWT algorithm confusion vulnerability (HS256 to none)",
          "targetEndpoint": "/api/admin/users",
          "httpMethod": "GET",
          "attackMethod": "JWT algorithm manipulation",
          "attackPayload": {
            "headers": {
              "Authorization": "Bearer eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VyX2lkIjoiVVNFUjAwMSIsInVzZXJfdHlwZSI6IkEiLCJyb2xlcyI6WyJST0xFX0FETUlOIl0sInNlc3Npb25faWQiOiJhZG1pbi1zZXNzaW9uIiwic3ViIjoiVVNFUjAwMSIsImlhdCI6MTcwNTY2MDgwMCwiZXhwIjoxNzA1NjYyNjAwfQ."
            }
          },
          "expectedResult": {
            "responseCode": 401,
            "securityMeasure": "JWT decoder rejects 'none' algorithm tokens",
            "validationCriteria": "Algorithm confusion attack should be prevented"
          },
          "validationSteps": [
            "Create JWT token with 'none' algorithm header",
            "Include admin privileges in token payload",
            "Attempt to access admin-only endpoint",
            "Verify Spring Security rejects unsigned token",
            "Confirm proper algorithm validation enforcement"
          ]
        },
        {
          "scenarioId": "AUTH_BYPASS_003",
          "name": "JWT Token Replay Attack",
          "description": "Test protection against expired and replayed JWT tokens",
          "targetEndpoint": "/api/accounts/12345678901",
          "httpMethod": "PUT",
          "attackMethod": "Expired token replay",
          "attackPayload": {
            "headers": {
              "Authorization": "Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoiVVNFUjAwMSIsInVzZXJfdHlwZSI6IlUiLCJyb2xlcyI6WyJST0xFX1VTRVIiXSwic2Vzc2lvbl9pZCI6ImV4cGlyZWQtc2Vzc2lvbiIsInN1YiI6IlVTRVIwMDEiLCJpYXQiOjE3MDU2NTcyMDAsImV4cCI6MTcwNTY1OTAwMH0.EXPIRED_TOKEN_SIGNATURE"
            },
            "body": {
              "accountStatus": "I"
            }
          },
          "expectedResult": {
            "responseCode": 401,
            "securityMeasure": "JWT expiration validation prevents token replay",
            "validationCriteria": "Expired token should be rejected"
          },
          "validationSteps": [
            "Use previously valid but expired JWT token",
            "Attempt to perform account update operation",
            "Verify token expiration is properly validated",
            "Confirm 401 response with appropriate error message",
            "Validate session cleanup prevents token reuse"
          ]
        }
      ]
    },

    "sessionHijackingScenarios": {
      "description": "Session hijacking and session management security testing for Redis-backed Spring Session implementation",
      "testEnvironment": {
        "sessionStore": "Redis 7+ with Spring Session configuration",
        "sessionSecurity": "Secure session tokens with TTL-based expiration",
        "securityControls": ["Session token rotation", "Secure cookie attributes", "Session invalidation"]
      },

      "attackVectors": [
        {
          "scenarioId": "SESSION_HIJ_001",
          "name": "Session Token Interception Attack",
          "description": "Test protection against intercepted session tokens",
          "attackMethod": "Session token theft simulation",
          "testScenario": {
            "step1": "Legitimate user establishes authenticated session",
            "step2": "Attacker attempts to use intercepted session token",
            "step3": "System should detect and prevent unauthorized session use"
          },
          "attackPayload": {
            "stolenSessionId": "intercepted-session-12345",
            "maliciousRequests": [
              {
                "endpoint": "/api/accounts/12345678901",
                "method": "GET",
                "headers": {
                  "Cookie": "SESSION=intercepted-session-12345"
                }
              }
            ]
          },
          "expectedResult": {
            "securityMeasure": "Session validation and user agent checking",
            "validationCriteria": "Hijacked session should be invalidated"
          },
          "validationSteps": [
            "Simulate session token interception",
            "Attempt to use stolen session from different source",
            "Verify session security controls detect anomaly",
            "Confirm automatic session invalidation occurs"
          ]
        },
        {
          "scenarioId": "SESSION_HIJ_002",
          "name": "Session Fixation Attack",
          "description": "Test protection against session fixation vulnerabilities",
          "attackMethod": "Pre-authentication session fixation",
          "testScenario": {
            "step1": "Attacker provides predetermined session ID to victim",
            "step2": "Victim authenticates with fixed session ID",
            "step3": "System should regenerate session after authentication"
          },
          "attackPayload": {
            "fixedSessionId": "attacker-controlled-session-id",
            "authenticationRequest": {
              "endpoint": "/api/auth/login",
              "method": "POST",
              "headers": {
                "Cookie": "SESSION=attacker-controlled-session-id"
              },
              "body": {
                "username": "USER001",
                "password": "validpassword"
              }
            }
          },
          "expectedResult": {
            "securityMeasure": "Session regeneration after authentication",
            "validationCriteria": "New session ID should be generated post-authentication"
          },
          "validationSteps": [
            "Provide fixed session ID before authentication",
            "Authenticate with valid credentials",
            "Verify new session ID is generated",
            "Confirm fixed session ID is invalidated"
          ]
        },
        {
          "scenarioId": "SESSION_HIJ_003",
          "name": "Concurrent Session Attack",
          "description": "Test protection against multiple concurrent sessions per user",
          "attackMethod": "Multiple simultaneous sessions",
          "testScenario": {
            "step1": "User authenticates from multiple locations simultaneously",
            "step2": "System should enforce session limits or detect anomalies",
            "step3": "Appropriate security measures should be triggered"
          },
          "attackPayload": {
            "concurrentLogins": [
              {
                "location": "Location1",
                "userAgent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64)",
                "ipAddress": "192.168.1.100"
              },
              {
                "location": "Location2", 
                "userAgent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7)",
                "ipAddress": "10.0.0.50"
              }
            ]
          },
          "expectedResult": {
            "securityMeasure": "Concurrent session monitoring and controls",
            "validationCriteria": "Suspicious concurrent sessions should be flagged"
          },
          "validationSteps": [
            "Establish multiple simultaneous sessions for same user",
            "Monitor session management behavior", 
            "Verify security controls detect anomalous activity",
            "Confirm appropriate security response is triggered"
          ]
        }
      ]
    },

    "jwtTokenManipulationTests": {
      "description": "Comprehensive JWT token manipulation testing covering signature validation, payload tampering, and cryptographic attacks",
      "testEnvironment": {
        "jwtImplementation": "Spring Security OAuth2 Resource Server with NimbusJwtDecoder",
        "algorithm": "HS256 with configurable secret key rotation",
        "securityControls": ["Signature validation", "Expiration checking", "Algorithm verification"]
      },

      "attackVectors": [
        {
          "scenarioId": "JWT_MANIP_001",
          "name": "JWT Payload Privilege Escalation",
          "description": "Attempt to escalate privileges by modifying JWT payload claims",
          "attackMethod": "Token payload manipulation",
          "testCase": {
            "originalToken": {
              "header": {"alg": "HS256", "typ": "JWT"},
              "payload": {
                "user_id": "USER001",
                "user_type": "U", 
                "roles": ["ROLE_USER"],
                "session_id": "user-session-12345",
                "sub": "USER001",
                "iat": 1705660800,
                "exp": 1705662600
              }
            },
            "manipulatedToken": {
              "header": {"alg": "HS256", "typ": "JWT"},
              "payload": {
                "user_id": "USER001",
                "user_type": "A",
                "roles": ["ROLE_ADMIN", "ROLE_USER"],
                "session_id": "elevated-session-12345",
                "sub": "USER001", 
                "iat": 1705660800,
                "exp": 1705662600
              }
            }
          },
          "attackPayload": {
            "targetEndpoint": "/api/admin/users",
            "method": "GET",
            "headers": {
              "Authorization": "Bearer MANIPULATED_JWT_WITH_ADMIN_CLAIMS"
            }
          },
          "expectedResult": {
            "responseCode": 401,
            "securityMeasure": "JWT signature validation prevents payload tampering",
            "validationCriteria": "Modified payload should invalidate token signature"
          },
          "validationSteps": [
            "Decode legitimate user JWT token",
            "Modify payload to include admin privileges",
            "Re-encode token with original signature",
            "Attempt to access admin-only endpoint",
            "Verify signature validation prevents privilege escalation"
          ]
        },
        {
          "scenarioId": "JWT_MANIP_002",
          "name": "JWT Algorithm Substitution Attack",
          "description": "Test protection against algorithm substitution attacks (RS256 to HS256)",
          "attackMethod": "Algorithm downgrade attack",
          "testCase": {
            "scenario": "Attempt to change RSA signature to HMAC using public key as secret",
            "riskAssessment": "Could allow token forgery if public key is used as HMAC secret"
          },
          "attackPayload": {
            "maliciousToken": {
              "header": {"alg": "HS256", "typ": "JWT"},
              "payload": {
                "user_id": "ADMIN001",
                "user_type": "A",
                "roles": ["ROLE_ADMIN"],
                "sub": "ADMIN001",
                "iat": 1705660800,
                "exp": 1705662600
              },
              "signature": "HMAC_SIGNATURE_WITH_PUBLIC_KEY_AS_SECRET"
            }
          },
          "expectedResult": {
            "responseCode": 401,
            "securityMeasure": "Algorithm validation prevents substitution attacks",
            "validationCriteria": "JWT decoder should reject algorithm mismatch"
          },
          "validationSteps": [
            "Create token with algorithm different from server configuration",
            "Attempt authentication with substituted algorithm token",
            "Verify server rejects algorithm mismatch",
            "Confirm no fallback to weaker algorithm occurs"
          ]
        },
        {
          "scenarioId": "JWT_MANIP_003",
          "name": "JWT Key Confusion Attack",
          "description": "Test protection against key confusion and weak key attacks",
          "attackMethod": "Weak key/key confusion exploitation",
          "testCase": {
            "scenario": "Attempt to exploit predictable or weak JWT signing keys",
            "commonWeakKeys": ["secret", "key", "jwt", "token", "password"]
          },
          "attackPayload": {
            "bruteForceAttempts": [
              {
                "guessedKey": "secret",
                "forgedToken": "JWT_SIGNED_WITH_WEAK_KEY_SECRET"
              },
              {
                "guessedKey": "key",
                "forgedToken": "JWT_SIGNED_WITH_WEAK_KEY_KEY"
              }
            ]
          },
          "expectedResult": {
            "securityMeasure": "Strong key configuration prevents weak key attacks",
            "validationCriteria": "Server should use cryptographically strong signing keys"
          },
          "validationSteps": [
            "Attempt to forge tokens using common weak keys",
            "Test token validation against guessed keys", 
            "Verify strong key configuration prevents exploitation",
            "Confirm proper key rotation mechanisms are in place"
          ]
        }
      ]
    },

    "authorizationBoundaryTesting": {
      "description": "Authorization boundary testing for Spring Security role-based access control and method-level security",
      "testEnvironment": {
        "authorizationFramework": "Spring Security with @PreAuthorize annotations",
        "roleMapping": "RACF groups to Spring Security roles (ADMIN/USER)",
        "securityControls": ["Method-level authorization", "Role-based access control", "Resource-level permissions"]
      },

      "attackVectors": [
        {
          "scenarioId": "AUTHZ_BOUND_001",
          "name": "Horizontal Privilege Escalation",
          "description": "Test protection against accessing other users' data at same privilege level",
          "attackMethod": "Cross-user data access attempt",
          "testCase": {
            "authenticatedUser": {
              "userId": "USER001",
              "role": "ROLE_USER",
              "allowedAccounts": ["12345678901", "12345678902"]
            },
            "targetResource": {
              "endpoint": "/api/cavw/accounts/98765432101",
              "owner": "USER002",
              "accessLevel": "user-only"
            }
          },
          "attackPayload": {
            "headers": {
              "Authorization": "Bearer USER001_VALID_JWT_TOKEN"
            },
            "targetEndpoint": "/api/cavw/accounts/98765432101"
          },
          "expectedResult": {
            "responseCode": 403,
            "securityMeasure": "Resource-level authorization prevents cross-user access",
            "validationCriteria": "Access should be denied to other users' accounts"
          },
          "validationSteps": [
            "Authenticate as USER001 with valid credentials",
            "Attempt to access account belonging to USER002",
            "Verify 403 Forbidden response",
            "Confirm no sensitive data leaked in error response"
          ]
        },
        {
          "scenarioId": "AUTHZ_BOUND_002",
          "name": "Vertical Privilege Escalation",
          "description": "Test protection against accessing higher privilege level functions",
          "attackMethod": "Role elevation attempt",
          "testCase": {
            "authenticatedUser": {
              "userId": "USER001",
              "role": "ROLE_USER",
              "limitations": "Cannot access admin functions"
            },
            "targetResource": {
              "endpoint": "/api/admin/users",
              "requiredRole": "ROLE_ADMIN",
              "function": "User management"
            }
          },
          "attackPayload": {
            "headers": {
              "Authorization": "Bearer USER001_ROLE_USER_JWT_TOKEN"
            },
            "targetEndpoint": "/api/admin/users",
            "method": "GET"
          },
          "expectedResult": {
            "responseCode": 403,
            "securityMeasure": "@PreAuthorize annotation prevents role escalation",
            "validationCriteria": "Regular user should not access admin endpoints"
          },
          "validationSteps": [
            "Authenticate as regular user (ROLE_USER)",
            "Attempt to access admin-only endpoint",
            "Verify @PreAuthorize('hasRole(ADMIN)') blocks access",
            "Confirm proper 403 Forbidden response"
          ]
        },
        {
          "scenarioId": "AUTHZ_BOUND_003",
          "name": "Method-Level Security Bypass",
          "description": "Test method-level security enforcement and bypass attempts",
          "attackMethod": "Direct method invocation bypass",
          "testCase": {
            "scenario": "Attempt to bypass @PreAuthorize through alternative access paths",
            "protectedMethod": "UserManagementService.deleteUser()"
          },
          "attackPayload": {
            "directMethodAccess": {
              "endpoint": "/api/admin/users/USER001",
              "method": "DELETE",
              "headers": {
                "Authorization": "Bearer ROLE_USER_JWT_TOKEN"
              }
            },
            "alternativeEndpoints": [
              "/api/users/USER001/delete",
              "/api/user-management/delete/USER001"
            ]
          },
          "expectedResult": {
            "responseCode": 403,
            "securityMeasure": "Method-level security prevents unauthorized operations",
            "validationCriteria": "All access paths should enforce @PreAuthorize rules"
          },
          "validationSteps": [
            "Attempt user deletion with insufficient privileges",
            "Test alternative endpoint patterns for same operation",
            "Verify consistent authorization enforcement",
            "Confirm no bypass paths exist for protected methods"
          ]
        }
      ]
    },

    "containerSecurityValidation": {
      "description": "Container and Kubernetes security testing for cloud-native security patterns and container protection",
      "testEnvironment": {
        "containerRuntime": "Docker with Spring Boot containerized microservices",
        "orchestration": "Kubernetes with namespace isolation and RBAC",
        "securityControls": ["Pod security policies", "Network policies", "Service mesh security"]
      },

      "attackVectors": [
        {
          "scenarioId": "CONTAINER_SEC_001",
          "name": "Container Escape Attempt",
          "description": "Test container isolation and escape prevention mechanisms",
          "attackMethod": "Container breakout simulation",
          "testCase": {
            "scenario": "Attempt to break out of Spring Boot application container",
            "techniques": ["Privileged container exploitation", "Host namespace access"]
          },
          "attackPayload": {
            "techniques": [
              {
                "method": "Privileged escalation",
                "command": "Access host filesystem from container",
                "expectedBlocked": true
              },
              {
                "method": "Namespace bypass",
                "command": "Escape container network namespace",
                "expectedBlocked": true
              }
            ]
          },
          "expectedResult": {
            "securityMeasure": "Container security constraints prevent escapes",
            "validationCriteria": "All escape attempts should be blocked"
          },
          "validationSteps": [
            "Deploy Spring Boot microservice in restricted container",
            "Attempt various container escape techniques",
            "Verify security constraints prevent host access",
            "Confirm container isolation boundaries are maintained"
          ]
        },
        {
          "scenarioId": "CONTAINER_SEC_002",
          "name": "Inter-Container Communication Attack",
          "description": "Test network policies and inter-service communication security",
          "attackMethod": "Unauthorized inter-container access",
          "testCase": {
            "scenario": "Attempt to access other microservices without authorization",
            "networkSegmentation": "Kubernetes network policies for service isolation"
          },
          "attackPayload": {
            "sourceContainer": "carddemo-account-service",
            "targetContainer": "carddemo-admin-service", 
            "unauthorizedRequests": [
              "HTTP requests to admin endpoints",
              "Database connection attempts",
              "Service discovery exploitation"
            ]
          },
          "expectedResult": {
            "securityMeasure": "Network policies block unauthorized inter-service communication",
            "validationCriteria": "Service-to-service communication should be properly restricted"
          },
          "validationSteps": [
            "Deploy microservices with network policy restrictions",
            "Attempt unauthorized inter-service communication",
            "Verify network policies block illegal traffic",
            "Confirm legitimate service communication still works"
          ]
        },
        {
          "scenarioId": "CONTAINER_SEC_003",
          "name": "Container Image Vulnerability Exploitation",
          "description": "Test protection against vulnerabilities in container images",
          "attackMethod": "Known CVE exploitation attempt",
          "testCase": {
            "scenario": "Attempt to exploit known vulnerabilities in base images or dependencies",
            "vulnCategories": ["Base image CVEs", "Dependency vulnerabilities", "Configuration weaknesses"]
          },
          "attackPayload": {
            "cveExploits": [
              {
                "cveId": "CVE-2023-XXXX",
                "component": "Base OS vulnerability",
                "exploitAttempt": "Remote code execution"
              }
            ]
          },
          "expectedResult": {
            "securityMeasure": "Vulnerability scanning and patch management prevent exploitation", 
            "validationCriteria": "No high/critical vulnerabilities should be exploitable"
          },
          "validationSteps": [
            "Scan container images for known vulnerabilities",
            "Attempt to exploit discovered vulnerabilities",
            "Verify patching and mitigation effectiveness",
            "Confirm vulnerability management processes work"
          ]
        }
      ]
    },

    "kubernetesRBACTesting": {
      "description": "Kubernetes Role-Based Access Control (RBAC) security testing for namespace isolation and service account permissions",
      "testEnvironment": {
        "kubernetesVersion": "1.28+",
        "rbacConfiguration": "Namespace-based isolation with service account restrictions",
        "securityControls": ["Service account tokens", "Role bindings", "Cluster role restrictions"]
      },

      "attackVectors": [
        {
          "scenarioId": "K8S_RBAC_001", 
          "name": "Service Account Token Abuse",
          "description": "Test protection against service account token misuse and privilege escalation",
          "attackMethod": "Service account token exploitation",
          "testCase": {
            "scenario": "Attempt to use service account tokens for unauthorized cluster access",
            "serviceAccounts": [
              "carddemo-dev-service-account",
              "carddemo-admin-service-account"
            ]
          },
          "attackPayload": {
            "stolenToken": "eyJhbGciOiJSUzI1NiIs...KUBERNETES_SA_TOKEN",
            "unauthorizedOperations": [
              "List pods in other namespaces",
              "Access cluster secrets",
              "Modify cluster configurations"
            ]
          },
          "expectedResult": {
            "securityMeasure": "RBAC policies restrict service account permissions",
            "validationCriteria": "Service accounts should have minimal required permissions"
          },
          "validationSteps": [
            "Extract service account token from pod",
            "Attempt to perform unauthorized cluster operations",
            "Verify RBAC policies prevent privilege escalation",
            "Confirm least privilege principle enforcement"
          ]
        },
        {
          "scenarioId": "K8S_RBAC_002",
          "name": "Cross-Namespace Access Attempt",
          "description": "Test namespace isolation and cross-namespace access prevention",
          "attackMethod": "Namespace boundary violation",
          "testCase": {
            "sourceNamespace": "carddemo-dev",
            "targetNamespace": "carddemo-production",
            "unauthorizedAccess": "Access production secrets from dev namespace"
          },
          "attackPayload": {
            "crossNamespaceRequests": [
              "kubectl get secrets -n carddemo-production",
              "kubectl get pods -n kube-system",
              "Access to production database credentials"
            ]
          },
          "expectedResult": {
            "securityMeasure": "Namespace isolation prevents cross-namespace access",
            "validationCriteria": "Dev namespace should not access production resources"
          },
          "validationSteps": [
            "Authenticate with dev namespace service account",
            "Attempt to access production namespace resources",
            "Verify namespace isolation is enforced",
            "Confirm proper RBAC role binding restrictions"
          ]
        },
        {
          "scenarioId": "K8S_RBAC_003",
          "name": "Cluster Admin Privilege Escalation",
          "description": "Test protection against cluster administrator privilege escalation attempts",
          "attackMethod": "RBAC privilege escalation",
          "testCase": {
            "scenario": "Attempt to escalate from namespace admin to cluster admin",
            "targetPermissions": [
              "cluster-admin ClusterRole",
              "system:masters group access"
            ]
          },
          "attackPayload": {
            "escalationAttempts": [
              {
                "method": "ClusterRoleBinding creation",
                "payload": "Create binding to cluster-admin role"
              },
              {
                "method": "ServiceAccount modification",
                "payload": "Modify SA to gain cluster access"
              }
            ]
          },
          "expectedResult": {
            "securityMeasure": "RBAC prevents unauthorized privilege escalation",
            "validationCriteria": "Namespace admins should not gain cluster admin access"
          },
          "validationSteps": [
            "Authenticate with namespace admin permissions",
            "Attempt various privilege escalation techniques",
            "Verify RBAC policies prevent escalation",
            "Confirm audit logging captures escalation attempts"
          ]
        }
      ]
    }
  },

  "SecurityTestConfiguration": {
    "description": "Security testing configuration providing OWASP ZAP integration settings, vulnerability assessment profiles, attack vector definitions, and automated penetration test execution parameters",
    
    "owaspZAPIntegrationSettings": {
      "zapVersion": "2.16.1",
      "baseConfiguration": {
        "host": "localhost",
        "port": 8080,
        "apiKey": "${ZAP_API_KEY}",
        "timeout": 300000,
        "maxConcurrentScans": 3
      },
      
      "authenticationConfiguration": {
        "jwtAuthentication": {
          "enabled": true,
          "loginEndpoint": "/api/auth/login",
          "tokenExtractor": "response.body.token",
          "tokenHeader": "Authorization",
          "tokenPrefix": "Bearer ",
          "testCredentials": {
            "adminUser": {
              "username": "ADMIN001",
              "password": "adminpassword"
            },
            "regularUser": {
              "username": "USER001", 
              "password": "userpassword"
            }
          }
        },
        
        "csrfConfiguration": {
          "enabled": true,
          "tokenEndpoint": "/api/csrf/token",
          "tokenHeader": "X-CSRF-TOKEN",
          "cookieName": "XSRF-TOKEN"
        }
      },
      
      "scanningProfiles": {
        "quickScan": {
          "description": "Fast vulnerability scan for CI/CD pipeline",
          "spiderMaxDepth": 5,
          "activeScanStrength": "LOW",
          "passiveScanning": true,
          "maxScanTime": "10m"
        },
        
        "comprehensiveScan": {
          "description": "Thorough security assessment for release validation",
          "spiderMaxDepth": 15,
          "activeScanStrength": "HIGH", 
          "passiveScanning": true,
          "maxScanTime": "60m",
          "customPayloads": true
        },
        
        "pciDSSComplianceScan": {
          "description": "PCI DSS compliance validation scan",
          "focusAreas": [
            "Cardholder data protection",
            "Strong access control measures",
            "Regularly monitor network access",
            "Maintain information security policy"
          ],
          "requiredTests": [
            "SQL injection protection",
            "XSS prevention validation",
            "CSRF token enforcement",
            "Authentication bypass prevention"
          ]
        }
      }
    },

    "vulnerabilityAssessmentProfiles": {
      "description": "Comprehensive vulnerability assessment profiles targeting different attack categories and security domains",
      
      "webApplicationSecurity": {
        "owaspTop10Testing": {
          "enabled": true,
          "categories": [
            {
              "id": "A01:2021",
              "name": "Broken Access Control",
              "testScenarios": [
                "Vertical privilege escalation",
                "Horizontal privilege escalation", 
                "IDOR vulnerabilities",
                "Directory traversal"
              ]
            },
            {
              "id": "A03:2021",
              "name": "Injection",
              "testScenarios": [
                "SQL injection in all parameters",
                "NoSQL injection attempts",
                "Command injection testing",
                "LDAP injection validation"
              ]
            },
            {
              "id": "A05:2021",
              "name": "Security Misconfiguration", 
              "testScenarios": [
                "Default credentials testing",
                "Unnecessary features enabled",
                "Error message information disclosure",
                "Security header analysis"
              ]
            }
          ]
        },
        
        "apiSecurityTesting": {
          "restApiValidation": {
            "enabled": true,
            "testAreas": [
              "Authentication bypass attempts",
              "Authorization boundary testing",
              "Input validation failures",
              "Rate limiting effectiveness",
              "API versioning security"
            ]
          },
          
          "graphqlSecurity": {
            "enabled": false,
            "reason": "CardDemo uses REST APIs only"
          }
        }
      },
      
      "authenticationSecurity": {
        "jwtSecurityTesting": {
          "enabled": true,
          "testCategories": [
            {
              "category": "Token Structure Attacks",
              "tests": [
                "Algorithm confusion (none, HS256, RS256)",
                "Signature verification bypass",
                "Payload manipulation attempts",
                "Key confusion attacks"
              ]
            },
            {
              "category": "Token Lifecycle Attacks",
              "tests": [
                "Token replay attacks",
                "Expired token usage",
                "Token refresh vulnerabilities",
                "Session fixation through JWT"
              ]
            }
          ]
        },
        
        "sessionManagementTesting": {
          "enabled": true,
          "redisSessionSecurity": {
            "sessionHijacking": "Test session token theft protection",
            "sessionFixation": "Validate session regeneration after auth",
            "concurrentSessions": "Test multiple session handling",
            "sessionTimeout": "Verify proper session expiration"
          }
        }
      },
      
      "infrastructureSecurity": {
        "containerSecurityTesting": {
          "enabled": true,
          "dockerSecurity": {
            "privilegeEscalation": "Test container escape prevention",
            "networkIsolation": "Validate inter-container communication",
            "secretsManagement": "Test environment variable protection",
            "imageSecurity": "Scan for vulnerable base images"
          }
        },
        
        "kubernetesSecurity": {
          "enabled": true,
          "rbacTesting": {
            "serviceAccountSecurity": "Test SA token abuse prevention",
            "namespaceIsolation": "Validate cross-namespace access controls",
            "privilegeEscalation": "Test cluster admin escalation prevention",
            "networkPolicies": "Validate pod-to-pod communication restrictions"
          }
        }
      }
    },

    "attackVectorDefinitions": {
      "description": "Comprehensive attack vector definitions for systematic security testing across all application layers",
      
      "applicationLayer": {
        "injectionAttacks": {
          "sqlInjection": {
            "payloads": [
              "' OR '1'='1' --",
              "'; DROP TABLE users; --", 
              "' UNION SELECT * FROM users --",
              "1' AND (SELECT COUNT(*) FROM users) > 0 --"
            ],
            "targetParameters": ["username", "accountId", "userId", "search"],
            "expectedPrevention": "Parameterized queries and input validation"
          },
          
          "nosqlInjection": {
            "enabled": false,
            "reason": "CardDemo uses PostgreSQL relational database"
          },
          
          "commandInjection": {
            "payloads": [
              "; ls -la",
              "| whoami",
              "&& cat /etc/passwd",
              "`id`"
            ],
            "targetParameters": ["file", "command", "path"],
            "expectedPrevention": "Input sanitization and command filtering"
          }
        },
        
        "xssAttacks": {
          "reflectedXSS": {
            "payloads": [
              "<script>alert('XSS')</script>",
              "<img src=x onerror=alert('XSS')>",
              "javascript:alert('XSS')",
              "<svg onload=alert('XSS')>"
            ],
            "targetParameters": ["search", "name", "comment", "description"],
            "expectedPrevention": "Output encoding and CSP headers"
          },
          
          "storedXSS": {
            "payloads": [
              "<script>document.cookie='stolen'</script>",
              "<iframe src='javascript:alert(1)'></iframe>",
              "<object data='data:text/html,<script>alert(1)</script>'></object>"
            ],
            "targetFields": ["firstName", "lastName", "address", "notes"],
            "expectedPrevention": "Input validation and output encoding"
          },
          
          "domXSS": {
            "enabled": true,
            "reactComponentTesting": true,
            "targetComponents": ["AccountViewComponent", "TransactionComponent"],
            "expectedPrevention": "React built-in XSS protection"
          }
        }
      },
      
      "authenticationLayer": {
        "credentialAttacks": {
          "bruteForce": {
            "enabled": true,
            "targetEndpoint": "/api/auth/login",
            "attemptPattern": "Common password list against valid usernames",
            "expectedPrevention": "Account lockout and rate limiting"
          },
          
          "credentialStuffing": {
            "enabled": true,
            "technique": "Known credential pairs from breach databases",
            "expectedPrevention": "Rate limiting and account monitoring"
          }
        },
        
        "sessionAttacks": {
          "sessionFixation": {
            "technique": "Pre-authentication session ID injection",
            "expectedPrevention": "Session regeneration after authentication"
          },
          
          "sessionHijacking": {
            "technique": "Session token interception and reuse",
            "expectedPrevention": "Secure session management and rotation"
          }
        }
      },
      
      "authorizationLayer": {
        "privilegeEscalation": {
          "horizontal": {
            "description": "Access other users' data at same privilege level",
            "testScenario": "USER001 accessing USER002's account data",
            "expectedPrevention": "Resource-level authorization checks"
          },
          
          "vertical": {
            "description": "Access higher privilege level functions",
            "testScenario": "Regular user accessing admin endpoints",
            "expectedPrevention": "@PreAuthorize annotations and role checks"
          }
        },
        
        "accessControlBypass": {
          "directObjectReference": {
            "technique": "Manipulate object references to access unauthorized data",
            "testParameters": ["accountId", "userId", "transactionId"],
            "expectedPrevention": "Authorization checks on all object access"
          }
        }
      }
    },

    "securityControlValidation": {
      "description": "Security control validation framework for verifying effectiveness of implemented security measures",
      
      "inputValidation": {
        "serverSideValidation": {
          "enabled": true,
          "framework": "Jakarta Bean Validation with Spring Boot",
          "testAreas": [
            "Data type validation",
            "Length constraints",
            "Format validation",
            "Business rule enforcement"
          ],
          "bypassAttempts": [
            "Client-side validation bypass",
            "Parameter pollution attacks",
            "Encoding manipulation"
          ]
        },
        
        "clientSideValidation": {
          "enabled": true,
          "framework": "React component validation",
          "validationPoints": [
            "Form field constraints",
            "Real-time validation feedback",
            "User input sanitization"
          ],
          "securityNote": "Client-side validation for UX only, server-side for security"
        }
      },
      
      "outputEncoding": {
        "contextualEncoding": {
          "enabled": true,
          "contexts": [
            "HTML content encoding",
            "JavaScript context encoding", 
            "CSS context encoding",
            "URL parameter encoding"
          ],
          "framework": "React built-in encoding + manual encoding where needed"
        }
      },
      
      "cryptographicControls": {
        "passwordHashing": {
          "algorithm": "BCrypt",
          "configuration": "Minimum 12 salt rounds",
          "testValidation": "Password verification without plaintext storage"
        },
        
        "jwtSigning": {
          "algorithm": "HS256",
          "keyManagement": "Kubernetes secrets with rotation capability",
          "testValidation": "Signature verification and key strength"
        },
        
        "dataEncryption": {
          "inTransit": "TLS 1.3 for all communications",
          "atRest": "PostgreSQL encryption with pgcrypto",
          "testValidation": "Encryption strength and proper implementation"
        }
      }
    },

    "complianceTestingScenarios": {
      "description": "Compliance-specific testing scenarios for regulatory requirements and industry standards",
      
      "pciDSSCompliance": {
        "version": "4.0",
        "applicableRequirements": [
          {
            "requirement": "3.2.1",
            "description": "Do not store sensitive authentication data after authorization",
            "testScenario": "Verify no CVV, PIN, or full PAN stored in database",
            "validationMethod": "Database content analysis and application testing"
          },
          {
            "requirement": "4.2.1", 
            "description": "Use strong cryptography for transmission over open networks",
            "testScenario": "Verify TLS 1.3 usage for all data transmission",
            "validationMethod": "Network traffic analysis and cipher suite validation"
          },
          {
            "requirement": "6.2.4",
            "description": "Build secure applications and systems",
            "testScenario": "Comprehensive vulnerability assessment of application",
            "validationMethod": "OWASP ZAP scanning and manual security testing"
          },
          {
            "requirement": "8.2.1",
            "description": "Strong user authentication for cardholder data environment",
            "testScenario": "JWT authentication strength and session management",
            "validationMethod": "Authentication bypass testing and token security analysis"
          }
        ]
      },
      
      "soxCompliance": {
        "section": "404 - Management Assessment of Internal Controls",
        "requirements": [
          {
            "control": "Access Control Testing",
            "description": "Verify proper access controls over financial systems",
            "testScenario": "Role-based access control validation for financial functions",
            "validationMethod": "Authorization boundary testing and privilege escalation attempts"
          },
          {
            "control": "Audit Trail Completeness",
            "description": "Ensure complete audit trails for financial transactions",
            "testScenario": "Verify all financial operations are logged and traceable",
            "validationMethod": "Transaction logging analysis and audit trail validation"
          }
        ]
      }
    },

    "automatedPenetrationTestExecution": {
      "description": "Automated penetration test execution framework with CI/CD integration and comprehensive reporting",
      
      "executionFramework": {
        "testOrchestration": {
          "enabled": true,
          "framework": "JUnit 5 with custom security test annotations",
          "parallelExecution": true,
          "maxConcurrentTests": 5,
          "testTimeout": "30m"
        },
        
        "environmentSetup": {
          "testEnvironment": "Kubernetes namespace: carddemo-security-testing",
          "dataPreparation": "Automated test data loading with anonymized records",
          "serviceDeployment": "Temporary microservice deployment for testing",
          "cleanupProcedure": "Automatic environment teardown after test completion"
        }
      },
      
      "cicdIntegration": {
        "githubActions": {
          "enabled": true,
          "triggerConditions": [
            "Pull request to main branch",
            "Scheduled weekly full scan",
            "Manual security test execution"
          ],
          "workflowSteps": [
            "Deploy test environment",
            "Execute OWASP ZAP baseline scan", 
            "Run custom penetration tests",
            "Generate security report",
            "Clean up test environment"
          ]
        },
        
        "qualityGates": {
          "failureCriteria": {
            "highVulnerabilities": 0,
            "criticalVulnerabilities": 0,
            "authenticationBypass": "Not tolerated",
            "dataExposure": "Not tolerated"
          },
          "warningCriteria": {
            "mediumVulnerabilities": 5,
            "lowVulnerabilities": 20,
            "performanceImpact": "Response time degradation > 10%"
          }
        }
      },
      
      "reportGeneration": {
        "formats": [
          "HTML security dashboard",
          "JSON machine-readable results",
          "PDF executive summary",
          "SARIF for development tools integration"
        ],
        
        "reportSections": [
          {
            "section": "Executive Summary",
            "content": "High-level security posture assessment with risk scoring"
          },
          {
            "section": "Vulnerability Details",
            "content": "Detailed findings with proof of concept and remediation guidance"
          },
          {
            "section": "Compliance Assessment", 
            "content": "PCI DSS and SOX compliance validation results"
          },
          {
            "section": "Trend Analysis",
            "content": "Security improvement tracking over time"
          }
        ]
      }
    },

    "securityScanningParameters": {
      "description": "Detailed security scanning parameters for comprehensive vulnerability assessment and penetration testing execution",
      
      "scanConfiguration": {
        "scope": {
          "includedEndpoints": [
            "/api/auth/*",
            "/api/cavw/*", 
            "/api/accounts/*",
            "/api/admin/*",
            "/api/transactions/*"
          ],
          "excludedEndpoints": [
            "/actuator/health",
            "/actuator/info",
            "/swagger-ui/*",
            "/v3/api-docs/*"
          ],
          "domainRestrictions": [
            "localhost:8080",
            "carddemo-test.local"
          ]
        },
        
        "intensity": {
          "spiderConfiguration": {
            "maxDepth": 10,
            "maxChildren": 50,
            "maxDuration": "15m",
            "threadCount": 5
          },
          
          "activeScanConfiguration": {
            "strength": "HIGH",
            "alertThreshold": "MEDIUM",
            "maxRuleDuration": "5m",
            "maxScanDuration": "45m"
          }
        }
      },
      
      "authenticationParameters": {
        "jwtTokenManagement": {
          "automaticTokenRefresh": true,
          "tokenExpirationHandling": "Auto-refresh before expiration",
          "multiUserTesting": {
            "adminUser": "Test admin role access patterns",
            "regularUser": "Test user role limitations",
            "unauthorizedAccess": "Test unauthenticated access blocking"
          }
        },
        
        "sessionParameters": {
          "sessionTimeout": "30m",
          "concurrentSessionLimit": 1,
          "sessionInvalidationTesting": true
        }
      },
      
      "customSecurityTests": {
        "cardDemoSpecific": {
          "financialDataProtection": {
            "enabled": true,
            "testAreas": [
              "Account balance exposure prevention",
              "Transaction data access control", 
              "Card number masking validation",
              "SSN protection verification"
            ]
          },
          
          "businessLogicTesting": {
            "enabled": true,
            "scenarios": [
              "Account balance manipulation attempts",
              "Transaction amount tampering",
              "Interest calculation bypass attempts",
              "Batch processing security validation"
            ]
          }
        }
      },
      
      "reportingParameters": {
        "detailLevel": "COMPREHENSIVE",
        "includeProofOfConcept": true,
        "includeFalsePositiveAnalysis": true,
        "customMetrics": [
          "Authentication bypass attempts blocked",
          "Authorization violations prevented", 
          "Data exposure incidents (should be 0)",
          "Security control effectiveness percentage"
        ],
        
        "alertingConfiguration": {
          "immediateAlerts": [
            "Critical vulnerability discovered",
            "Authentication bypass successful",
            "Data exposure detected",
            "Compliance violation identified"
          ],
          "summaryReports": [
            "Daily security scan summary",
            "Weekly trend analysis",
            "Monthly compliance report"
          ]
        }
      }
    }
  }
}