# ===============================================================================
# Production-Optimized Spring Boot Configuration Profile
# CardDemo COBOL-to-Java Migration - Production Environment
# ===============================================================================
#
# This production configuration profile provides enterprise-grade optimization
# for the modernized CardDemo system supporting 10,000 TPS with sub-200ms
# response times at 95th percentile while maintaining exact COBOL business
# logic equivalence and VSAM data precision.
#
# Key Production Features:
# - PostgreSQL clustering with streaming replication and read replica routing
# - Redis cluster mode for high-availability distributed session management
# - Security hardening with enterprise-grade authentication and authorization
# - JVM memory optimization within 10% overhead of CICS baseline requirements
# - Comprehensive monitoring, metrics, and audit logging for compliance
# - Performance tuning for cloud-native microservices architecture
# - Production-grade connection pooling and resource management
# ===============================================================================

# Spring Boot Production Configuration
spring:
  application:
    name: carddemo
    version: ${APP_VERSION:1.0.0}
    instance_id: ${HOSTNAME:${random.uuid}}
  
  profiles:
    active: prod
  
  # ===============================================================================
  # Production PostgreSQL Database Configuration
  # Clustering with streaming replication and read replica routing
  # ===============================================================================
  datasource:
    # Primary database connection for write operations
    primary:
      jdbc-url: ${DB_PRIMARY_URL:jdbc:postgresql://carddemo-db-primary:5432/carddemo}
      username: ${DB_USERNAME:carddemo_prod}
      password: ${DB_PASSWORD}
      driver-class-name: org.postgresql.Driver
      
      # Production HikariCP connection pool settings
      # Optimized for 10,000 TPS with enterprise-grade monitoring
      hikari:
        # Connection pool sizing for high-throughput production workloads
        # Formula: (vCPU * 2) + effective_spindle_count, optimized for PostgreSQL
        maximum-pool-size: ${DB_POOL_SIZE:75}
        minimum-idle: ${DB_POOL_MIN_IDLE:15}
        connection-timeout: ${DB_CONNECTION_TIMEOUT:20000}
        idle-timeout: ${DB_IDLE_TIMEOUT:300000}
        max-lifetime: ${DB_MAX_LIFETIME:1200000}
        leak-detection-threshold: ${DB_LEAK_DETECTION:60000}
        validation-timeout: ${DB_VALIDATION_TIMEOUT:3000}
        
        # Production connection pool monitoring
        pool-name: CardDemoProductionPool
        register-mbeans: true
        
        # PostgreSQL production connection properties
        data-source-properties:
          ssl: ${DB_SSL_ENABLED:true}
          sslmode: ${DB_SSL_MODE:require}
          sslcert: ${DB_SSL_CERT_PATH:}
          sslkey: ${DB_SSL_KEY_PATH:}
          sslrootcert: ${DB_SSL_ROOT_CERT_PATH:}
          reWriteBatchedInserts: true
          defaultRowFetchSize: 1000
          prepareThreshold: 5
          connectTimeout: ${DB_CONNECT_TIMEOUT:10}
          socketTimeout: ${DB_SOCKET_TIMEOUT:30}
          tcpKeepAlive: true
          applicationName: ${spring.application.name}
          
    # Read replica configuration for read-heavy operations
    read-replica:
      jdbc-url: ${DB_REPLICA_URL:jdbc:postgresql://carddemo-db-replica:5432/carddemo}
      username: ${DB_REPLICA_USERNAME:carddemo_reader}
      password: ${DB_REPLICA_PASSWORD:${DB_PASSWORD}}
      driver-class-name: org.postgresql.Driver
      
      # Read replica connection pool settings
      hikari:
        maximum-pool-size: ${DB_REPLICA_POOL_SIZE:50}
        minimum-idle: ${DB_REPLICA_POOL_MIN_IDLE:10}
        connection-timeout: ${DB_CONNECTION_TIMEOUT:20000}
        idle-timeout: ${DB_IDLE_TIMEOUT:300000}
        max-lifetime: ${DB_MAX_LIFETIME:1200000}
        pool-name: CardDemoReplicaPool
        register-mbeans: true
        
        # Read replica connection properties
        data-source-properties:
          ssl: ${DB_SSL_ENABLED:true}
          sslmode: ${DB_SSL_MODE:require}
          readOnly: true
          defaultRowFetchSize: 1000
          prepareThreshold: 5
          connectTimeout: ${DB_CONNECT_TIMEOUT:10}
          socketTimeout: ${DB_SOCKET_TIMEOUT:30}
          tcpKeepAlive: true
          applicationName: ${spring.application.name}-replica
  
  # ===============================================================================
  # Production JPA Configuration
  # COBOL COMP-3 precision preservation with production optimizations
  # ===============================================================================
  jpa:
    hibernate:
      ddl-auto: validate
      naming:
        physical-strategy: org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl
        implicit-strategy: org.hibernate.boot.model.naming.ImplicitNamingStrategyJpaCompliantImpl
      
      # Production JDBC batch processing
      jdbc:
        batch_size: ${HIBERNATE_BATCH_SIZE:50}
        fetch_size: ${HIBERNATE_FETCH_SIZE:100}
        order_inserts: true
        order_updates: true
        batch_versioned_data: true
        
    database-platform: org.hibernate.dialect.PostgreSQLDialect
    show-sql: false
    
    # Production JPA properties
    properties:
      hibernate:
        format_sql: false
        use_sql_comments: false
        
        # Production connection isolation for VSAM-equivalent locking
        connection:
          isolation: SERIALIZABLE
          provider_disables_autocommit: true
          
        # Production JDBC optimizations
        jdbc:
          time_zone: UTC
          batch_size: ${HIBERNATE_BATCH_SIZE:50}
          fetch_size: ${HIBERNATE_FETCH_SIZE:100}
          lob:
            non_contextual_creation: true
            
        # Production query optimization
        query:
          plan_cache_max_size: ${HIBERNATE_PLAN_CACHE_SIZE:4096}
          plan_parameter_metadata_max_size: ${HIBERNATE_PLAN_METADATA_SIZE:256}
          
        # Production second-level cache configuration
        cache:
          use_second_level_cache: true
          use_query_cache: true
          region:
            factory_class: org.hibernate.cache.jcache.JCacheRegionFactory
            
        # Production statistics and monitoring
        generate_statistics: true
        session:
          events:
            log:
              LOG_QUERIES_SLOWER_THAN_MS: ${HIBERNATE_SLOW_QUERY_THRESHOLD:1000}
    
    open-in-view: false
  
  # ===============================================================================
  # Production Redis Cluster Configuration
  # High-availability distributed session management
  # ===============================================================================
  data:
    redis:
      # Redis cluster configuration for high availability
      cluster:
        nodes:
          - ${REDIS_CLUSTER_NODE1:carddemo-redis-node1:6379}
          - ${REDIS_CLUSTER_NODE2:carddemo-redis-node2:6379}
          - ${REDIS_CLUSTER_NODE3:carddemo-redis-node3:6379}
          - ${REDIS_CLUSTER_NODE4:carddemo-redis-node4:6379}
          - ${REDIS_CLUSTER_NODE5:carddemo-redis-node5:6379}
          - ${REDIS_CLUSTER_NODE6:carddemo-redis-node6:6379}
        max-redirects: ${REDIS_MAX_REDIRECTS:3}
        
      # Redis authentication and security
      password: ${REDIS_PASSWORD}
      username: ${REDIS_USERNAME:default}
      
      # Production connection settings
      timeout: ${REDIS_TIMEOUT:3000ms}
      connect-timeout: ${REDIS_CONNECT_TIMEOUT:5000ms}
      command-timeout: ${REDIS_COMMAND_TIMEOUT:3000ms}
      
      # Production SSL configuration
      ssl:
        enabled: ${REDIS_SSL_ENABLED:true}
        bundle: ${REDIS_SSL_BUNDLE:}
        
      # Production Lettuce connection pool
      lettuce:
        pool:
          max-active: ${REDIS_POOL_MAX_ACTIVE:100}
          max-idle: ${REDIS_POOL_MAX_IDLE:50}
          min-idle: ${REDIS_POOL_MIN_IDLE:10}
          max-wait: ${REDIS_POOL_MAX_WAIT:5000ms}
          time-between-eviction-runs: ${REDIS_POOL_EVICTION_INTERVAL:60000ms}
          
        # Production cluster refresh configuration
        cluster:
          refresh:
            adaptive: true
            period: ${REDIS_CLUSTER_REFRESH_PERIOD:30000ms}
            
        # Production shutdown timeout
        shutdown-timeout: ${REDIS_SHUTDOWN_TIMEOUT:10000ms}
      
      # Production Redis serialization
      serialize-options:
        key-serializer: org.springframework.data.redis.serializer.StringRedisSerializer
        value-serializer: org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer
        hash-key-serializer: org.springframework.data.redis.serializer.StringRedisSerializer
        hash-value-serializer: org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer
  
  # ===============================================================================
  # Production Session Management Configuration
  # ===============================================================================
  session:
    store-type: redis
    redis:
      namespace: ${REDIS_SESSION_NAMESPACE:carddemo:prod:sessions}
      flush-mode: immediate
      cleanup-cron: ${REDIS_SESSION_CLEANUP_CRON:0 */5 * * * *}
      timeout: ${SESSION_TIMEOUT:30m}
      serializer: json
      configure-action: notify_keyspace_events
      
      # Production session configuration
      repository:
        index-resolver: principal
        save-mode: on_set_attribute
        
  # ===============================================================================
  # Production Security Configuration
  # Enterprise-grade authentication and authorization
  # ===============================================================================
  security:
    # Production JWT configuration
    jwt:
      secret: ${JWT_SECRET}
      expiration: ${JWT_EXPIRATION:1800000}
      refresh-expiration: ${JWT_REFRESH_EXPIRATION:86400000}
      algorithm: ${JWT_ALGORITHM:HS256}
      issuer: ${JWT_ISSUER:carddemo-prod}
      audience: ${JWT_AUDIENCE:carddemo-users}
      
    # Production OAuth2 configuration
    oauth2:
      resource-server:
        jwt:
          issuer-uri: ${JWT_ISSUER_URI}
          jwk-set-uri: ${JWT_JWK_SET_URI}
          
    # Production password encoding
    password:
      encoder:
        strength: ${PASSWORD_ENCODER_STRENGTH:12}
        
  # ===============================================================================
  # Production Liquibase Configuration
  # ===============================================================================
  liquibase:
    change-log: classpath:db/liquibase-changelog.xml
    contexts: prod
    drop-first: false
    enabled: true
    parameters:
      app.name: ${spring.application.name}
      app.version: ${spring.application.version}
      schema.version: ${DB_SCHEMA_VERSION:1.0.0}
      migration.author: blitzy-agent
      migration.timestamp: ${spring.application.instance_id}
    rollback-on-error: true
    validate-on-migrate: true
    
  # ===============================================================================
  # Production Batch Processing Configuration
  # ===============================================================================
  batch:
    job:
      enabled: true
      repository:
        initialize-schema: never
        isolation-level-for-create: serializable
        execution:
          async: true
          pool-size: ${BATCH_EXECUTION_POOL_SIZE:20}
          queue-capacity: ${BATCH_EXECUTION_QUEUE_CAPACITY:200}
      scheduling:
        enabled: true
        pool-size: ${BATCH_SCHEDULING_POOL_SIZE:10}
    processing:
      chunk-size: ${BATCH_CHUNK_SIZE:2000}
      commit-interval: ${BATCH_COMMIT_INTERVAL:2000}
      skip-limit: ${BATCH_SKIP_LIMIT:50}
      retry-limit: ${BATCH_RETRY_LIMIT:3}
      
  # ===============================================================================
  # Production Jackson Configuration
  # ===============================================================================
  jackson:
    date-format: yyyy-MM-dd'T'HH:mm:ss.SSSXXX
    time-zone: UTC
    serialization:
      write-dates-as-timestamps: false
      write-numbers-as-strings: false
      write-bigdecimal-as-plain: true
      indent-output: false
      fail-on-empty-beans: false
    deserialization:
      use-big-decimal-for-floats: true
      use-big-integer-for-ints: false
      accept-single-value-as-array: true
      fail-on-unknown-properties: false
      fail-on-null-for-primitives: false
    property-naming-strategy: SNAKE_CASE
    default-property-inclusion: non_null
    
  # ===============================================================================
  # Production Cloud Configuration
  # ===============================================================================
  cloud:
    config:
      enabled: ${CONFIG_SERVER_ENABLED:true}
      uri: ${CONFIG_SERVER_URI}
      profile: prod
      label: ${CONFIG_SERVER_LABEL:main}
      refresh:
        enabled: true
        rate: ${CONFIG_REFRESH_RATE:60000}
      retry:
        initial-interval: ${CONFIG_RETRY_INITIAL:2000}
        max-interval: ${CONFIG_RETRY_MAX:30000}
        max-attempts: ${CONFIG_RETRY_MAX_ATTEMPTS:10}
        multiplier: ${CONFIG_RETRY_MULTIPLIER:1.2}
        
    discovery:
      enabled: ${SERVICE_DISCOVERY_ENABLED:true}
      service-id: ${spring.application.name}
      
    circuitbreaker:
      resilience4j:
        enabled: true
        
# ===============================================================================
# Production Server Configuration
# ===============================================================================
server:
  port: ${SERVER_PORT:8080}
  servlet:
    context-path: ${SERVER_CONTEXT_PATH:/}
    encoding:
      charset: UTF-8
      enabled: true
      force: true
      
  # Production Tomcat configuration
  tomcat:
    # Production connection settings optimized for 10,000 TPS
    accept-count: ${TOMCAT_ACCEPT_COUNT:500}
    max-connections: ${TOMCAT_MAX_CONNECTIONS:10000}
    max-threads: ${TOMCAT_MAX_THREADS:400}
    min-spare-threads: ${TOMCAT_MIN_SPARE_THREADS:50}
    
    # Production timeout settings
    connection-timeout: ${TOMCAT_CONNECTION_TIMEOUT:30000}
    keep-alive-timeout: ${TOMCAT_KEEP_ALIVE_TIMEOUT:60000}
    max-keep-alive-requests: ${TOMCAT_MAX_KEEP_ALIVE_REQUESTS:200}
    
    # Production performance optimizations
    uri-encoding: UTF-8
    use-relative-redirects: true
    
    # Production thread pool settings
    threads:
      max: ${TOMCAT_MAX_THREADS:400}
      min-spare: ${TOMCAT_MIN_SPARE_THREADS:50}
      
    # Production access log
    accesslog:
      enabled: true
      directory: /var/log/carddemo
      prefix: access_log
      suffix: .log
      pattern: combined
      rotate: true
      
  # Production compression
  compression:
    enabled: true
    min-response-size: 2048
    mime-types: text/html,text/plain,text/css,application/javascript,application/json,application/xml,text/xml
    
  # Production HTTP/2 support
  http2:
    enabled: true
    
  # Production SSL configuration
  ssl:
    enabled: ${SSL_ENABLED:true}
    key-store: ${SSL_KEYSTORE_PATH}
    key-store-password: ${SSL_KEYSTORE_PASSWORD}
    key-store-type: ${SSL_KEYSTORE_TYPE:PKCS12}
    protocol: ${SSL_PROTOCOL:TLS}
    enabled-protocols: ${SSL_ENABLED_PROTOCOLS:TLSv1.2,TLSv1.3}
    ciphers: ${SSL_CIPHERS:}
    
  # Production forward headers
  forward-headers-strategy: ${FORWARD_HEADERS_STRATEGY:native}
  
  # Production shutdown configuration
  shutdown: ${SERVER_SHUTDOWN:graceful}
  
# ===============================================================================
# Production Logging Configuration
# ===============================================================================
logging:
  level:
    # Production application logging levels
    com.carddemo: ${LOG_LEVEL_CARDDEMO:INFO}
    org.springframework.security: ${LOG_LEVEL_SECURITY:WARN}
    org.springframework.web: ${LOG_LEVEL_WEB:WARN}
    org.springframework.data: ${LOG_LEVEL_DATA:WARN}
    org.springframework.batch: ${LOG_LEVEL_BATCH:INFO}
    org.springframework.cloud: ${LOG_LEVEL_CLOUD:WARN}
    
    # Production database logging
    org.hibernate.SQL: ${LOG_LEVEL_SQL:WARN}
    org.hibernate.type.descriptor.sql.BasicBinder: ${LOG_LEVEL_SQL_BINDER:WARN}
    org.hibernate.engine.jdbc.batch.internal.BatchingBatch: ${LOG_LEVEL_SQL_BATCH:WARN}
    
    # Production connection pool logging
    com.zaxxer.hikari: ${LOG_LEVEL_HIKARI:WARN}
    com.zaxxer.hikari.pool.HikariPool: ${LOG_LEVEL_HIKARI_POOL:WARN}
    
    # Production actuator logging
    org.springframework.boot.actuate: ${LOG_LEVEL_ACTUATOR:WARN}
    
    # Production root logging level
    root: ${LOG_LEVEL_ROOT:WARN}
    
  # Production log file configuration
  file:
    name: ${LOG_FILE_NAME:/var/log/carddemo/carddemo.log}
    path: ${LOG_FILE_PATH:/var/log/carddemo}
    
  # Production logging pattern (JSON structured logging handled by logback-spring.xml)
  pattern:
    console: "%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level [%X{correlationId:-}] [%X{userId:-}] %logger{36} - %msg%n"
    file: "%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level [%X{correlationId:-}] [%X{userId:-}] %logger{36} - %msg%n"
    
  # Production log configuration
  config: ${LOG_CONFIG:classpath:logback-spring.xml}
  
# ===============================================================================
# Production Actuator Configuration
# ===============================================================================
management:
  endpoints:
    web:
      exposure:
        include: ${ACTUATOR_ENDPOINTS:health,info,metrics,prometheus}
      base-path: ${ACTUATOR_BASE_PATH:/actuator}
      cors:
        allowed-origins: ${ACTUATOR_CORS_ORIGINS:}
        allowed-methods: ${ACTUATOR_CORS_METHODS:GET,POST}
        
  endpoint:
    health:
      show-details: ${ACTUATOR_HEALTH_SHOW_DETAILS:when-authorized}
      show-components: ${ACTUATOR_HEALTH_SHOW_COMPONENTS:when-authorized}
      probes:
        enabled: ${ACTUATOR_HEALTH_PROBES_ENABLED:true}
        
    info:
      enabled: ${ACTUATOR_INFO_ENABLED:true}
      
    metrics:
      enabled: ${ACTUATOR_METRICS_ENABLED:true}
      
    prometheus:
      enabled: ${ACTUATOR_PROMETHEUS_ENABLED:true}
      
    loggers:
      enabled: ${ACTUATOR_LOGGERS_ENABLED:false}
      
    env:
      enabled: ${ACTUATOR_ENV_ENABLED:false}
      
    auditevents:
      enabled: ${ACTUATOR_AUDIT_ENABLED:true}
      
    shutdown:
      enabled: ${ACTUATOR_SHUTDOWN_ENABLED:false}
      
  # Production health checks
  health:
    # Database health check
    db:
      enabled: true
      
    # Redis health check
    redis:
      enabled: true
      
    # Diskspace health check
    diskspace:
      enabled: true
      threshold: ${HEALTH_DISKSPACE_THRESHOLD:1GB}
      
    # Ping health check
    ping:
      enabled: true
      
    # Liveness and readiness probes
    livenessstate:
      enabled: true
      
    readinessstate:
      enabled: true
      
  # Production metrics configuration
  metrics:
    enabled: true
    export:
      prometheus:
        enabled: true
        descriptions: true
        step: ${METRICS_PROMETHEUS_STEP:60s}
        
    # JVM metrics
    jvm:
      enabled: true
      
    # System metrics
    system:
      enabled: true
      
    # Web metrics
    web:
      server:
        enabled: true
        request:
          autotime:
            enabled: true
            percentiles: 0.5,0.9,0.95,0.99
            percentiles-histogram: true
            
    # HikariCP metrics
    hikaricp:
      enabled: true
      
    # JPA metrics
    jpa:
      enabled: true
      
    # Cache metrics
    cache:
      enabled: true
      
    # Redis metrics
    redis:
      enabled: true
      
    # Batch metrics
    batch:
      enabled: true
      
    # Custom metrics
    custom:
      enabled: true
      
  # Production audit events
  auditevents:
    enabled: true
    
  # Production security for actuator
  security:
    enabled: ${ACTUATOR_SECURITY_ENABLED:true}
    
  # Production application info
  info:
    app:
      name: ${spring.application.name}
      version: ${spring.application.version}
      description: CardDemo Production Environment
      encoding: ${file.encoding:UTF-8}
      java:
        version: ${java.version}
        vendor: ${java.vendor}
        
    build:
      artifact: ${spring.application.name}
      version: ${spring.application.version}
      time: ${build.time:}
      
    git:
      mode: ${INFO_GIT_MODE:simple}
      
    env:
      enabled: ${INFO_ENV_ENABLED:true}
      
    java:
      enabled: ${INFO_JAVA_ENABLED:true}
      
    os:
      enabled: ${INFO_OS_ENABLED:true}
      
# ===============================================================================
# Production Custom Application Properties
# ===============================================================================
carddemo:
  # Production application metadata
  application:
    name: CardDemo
    description: COBOL-to-Java Migration Production Environment
    version: ${spring.application.version}
    environment: production
    
  # Production business configuration
  business:
    # Production transaction processing
    transaction:
      timeout: ${BUSINESS_TRANSACTION_TIMEOUT:20000}
      retry-attempts: ${BUSINESS_TRANSACTION_RETRY:3}
      batch-size: ${BUSINESS_TRANSACTION_BATCH_SIZE:2000}
      
    # Production account management
    account:
      max-accounts-per-customer: ${BUSINESS_ACCOUNT_MAX_PER_CUSTOMER:10}
      default-credit-limit: ${BUSINESS_ACCOUNT_DEFAULT_CREDIT_LIMIT:5000.00}
      
    # Production card management
    card:
      expiration-years: ${BUSINESS_CARD_EXPIRATION_YEARS:3}
      cvv-regeneration-interval: ${BUSINESS_CARD_CVV_REGENERATION:365}
      
  # Production security configuration
  security:
    # Production session management
    session:
      timeout: ${SECURITY_SESSION_TIMEOUT:1800}
      max-concurrent-sessions: ${SECURITY_SESSION_MAX_CONCURRENT:1}
      
    # Production authentication
    authentication:
      max-login-attempts: ${SECURITY_AUTH_MAX_LOGIN_ATTEMPTS:3}
      lockout-duration: ${SECURITY_AUTH_LOCKOUT_DURATION:1800}
      
    # Production authorization
    authorization:
      admin-role: ${SECURITY_AUTH_ADMIN_ROLE:ROLE_ADMIN}
      user-role: ${SECURITY_AUTH_USER_ROLE:ROLE_USER}
      
  # Production performance tuning
  performance:
    # Production database configuration
    database:
      pool-size: ${PERFORMANCE_DB_POOL_SIZE:75}
      connection-timeout: ${PERFORMANCE_DB_CONNECTION_TIMEOUT:20000}
      
    # Production cache configuration
    cache:
      ttl: ${PERFORMANCE_CACHE_TTL:600}
      max-entries: ${PERFORMANCE_CACHE_MAX_ENTRIES:50000}
      
    # Production batch processing
    batch:
      chunk-size: ${PERFORMANCE_BATCH_CHUNK_SIZE:2000}
      thread-pool-size: ${PERFORMANCE_BATCH_THREAD_POOL_SIZE:20}
      
    # Production JVM tuning
    jvm:
      heap-size: ${JVM_HEAP_SIZE:4g}
      new-size: ${JVM_NEW_SIZE:1g}
      max-metaspace-size: ${JVM_MAX_METASPACE_SIZE:512m}
      gc-threads: ${JVM_GC_THREADS:4}
      
  # Production integration settings
  integration:
    # External service integration
    external:
      timeout: ${INTEGRATION_EXTERNAL_TIMEOUT:15000}
      retry-attempts: ${INTEGRATION_EXTERNAL_RETRY:3}
      circuit-breaker-enabled: ${INTEGRATION_EXTERNAL_CIRCUIT_BREAKER:true}
      
    # Internal service integration
    internal:
      timeout: ${INTEGRATION_INTERNAL_TIMEOUT:10000}
      retry-attempts: ${INTEGRATION_INTERNAL_RETRY:2}
      
  # Production monitoring configuration
  monitoring:
    # Metrics collection
    metrics:
      enabled: ${MONITORING_METRICS_ENABLED:true}
      collection-interval: ${MONITORING_METRICS_COLLECTION_INTERVAL:60s}
      
    # Tracing configuration
    tracing:
      enabled: ${MONITORING_TRACING_ENABLED:true}
      sample-rate: ${MONITORING_TRACING_SAMPLE_RATE:0.1}
      
    # Alerting configuration
    alerting:
      enabled: ${MONITORING_ALERTING_ENABLED:true}
      
  # Production audit configuration
  audit:
    enabled: ${AUDIT_ENABLED:true}
    log-all-requests: ${AUDIT_LOG_ALL_REQUESTS:true}
    log-authentication-events: ${AUDIT_LOG_AUTH_EVENTS:true}
    log-authorization-events: ${AUDIT_LOG_AUTHZ_EVENTS:true}
    log-data-changes: ${AUDIT_LOG_DATA_CHANGES:true}
    retention-days: ${AUDIT_RETENTION_DAYS:2555}
    
  # Production backup configuration
  backup:
    enabled: ${BACKUP_ENABLED:true}
    schedule: ${BACKUP_SCHEDULE:0 2 * * *}
    retention-days: ${BACKUP_RETENTION_DAYS:90}
    
# ===============================================================================
# Production JVM Configuration
# Memory optimization within 10% overhead of CICS baseline
# ===============================================================================
java:
  # Production JVM options
  opts:
    # Memory settings optimized for production workload
    heap:
      initial: ${JVM_HEAP_INITIAL:2g}
      maximum: ${JVM_HEAP_MAXIMUM:4g}
      
    # Garbage collection tuning
    gc:
      algorithm: ${JVM_GC_ALGORITHM:G1GC}
      max-gc-pause-millis: ${JVM_GC_MAX_PAUSE:200}
      
    # Performance optimizations
    performance:
      server-mode: true
      optimize-string-concat: true
      
    # Monitoring and diagnostics
    monitoring:
      jmx-enabled: true
      flight-recorder-enabled: ${JVM_FLIGHT_RECORDER_ENABLED:true}
      
# ===============================================================================
# Production Environment Variables Documentation
# ===============================================================================
# The following environment variables should be set in production deployment:
#
# Database Configuration:
# - DB_PRIMARY_URL: Primary PostgreSQL database URL
# - DB_REPLICA_URL: Read replica PostgreSQL database URL
# - DB_USERNAME: Database username
# - DB_PASSWORD: Database password
# - DB_REPLICA_USERNAME: Read replica database username
# - DB_REPLICA_PASSWORD: Read replica database password
#
# Redis Configuration:
# - REDIS_CLUSTER_NODE1-6: Redis cluster node endpoints
# - REDIS_PASSWORD: Redis cluster password
# - REDIS_USERNAME: Redis cluster username
#
# Security Configuration:
# - JWT_SECRET: JWT signing secret key
# - JWT_ISSUER_URI: JWT issuer URI
# - JWT_JWK_SET_URI: JWT JWK set URI
#
# SSL Configuration:
# - SSL_KEYSTORE_PATH: SSL keystore file path
# - SSL_KEYSTORE_PASSWORD: SSL keystore password
#
# Application Configuration:
# - APP_VERSION: Application version
# - HOSTNAME: Application hostname
# - SERVER_PORT: Application server port
#
# Monitoring Configuration:
# - ACTUATOR_ENDPOINTS: Exposed actuator endpoints
# - METRICS_PROMETHEUS_STEP: Prometheus metrics collection interval
# ===============================================================================