package com.carddemo.common.dto;

import com.fasterxml.jackson.annotation.JsonProperty;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;
import java.time.LocalDateTime;
import java.util.Objects;

/**
 * Base request DTO providing common fields and structure for all API request DTOs.
 * This class implements the foundational request structure for the CardDemo microservices 
 * architecture, supporting distributed transaction tracking, user context preservation,
 * and comprehensive audit trail requirements.
 * 
 * <p>Key Features:
 * <ul>
 *   <li>Correlation ID support for distributed transaction tracking across microservices</li>
 *   <li>User context information for audit trails and authorization</li>
 *   <li>Session management integration with Redis-backed session storage</li>
 *   <li>Jackson JSON serialization annotations for consistent API formatting</li>
 *   <li>Request metadata fields for transaction correlation and compliance</li>
 * </ul>
 * 
 * <p>Security Integration:
 * This DTO integrates with Spring Security JWT authentication framework and supports
 * the role-based access control patterns established in the system. The user context
 * fields align with JWT token claims structure for seamless authorization processing.
 * 
 * <p>Usage Pattern:
 * All request DTOs in the system must extend this base class to ensure consistent
 * request structure across all microservices and proper correlation tracking for
 * distributed operations.
 * 
 * @author Blitzy Agent
 * @version 1.0
 * @since 2024-01-01
 */
public class BaseRequestDto {

    /**
     * Unique correlation identifier for distributed transaction tracking.
     * This field enables request tracing across multiple microservices and supports
     * comprehensive audit trail requirements for financial transaction processing.
     * 
     * Format: UUID string (36 characters including hyphens)
     * Usage: Generated by client or API gateway for request correlation
     */
    @JsonProperty("correlationId")
    @NotBlank(message = "Correlation ID is required for request tracking")
    @Size(min = 36, max = 36, message = "Correlation ID must be a valid UUID format")
    @Pattern(regexp = "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$", 
             message = "Correlation ID must be a valid UUID format")
    private String correlationId;

    /**
     * User identifier for audit trail and authorization context.
     * This field captures the authenticated user making the request, supporting
     * Spring Security integration and role-based access control patterns.
     * 
     * Format: Alphanumeric string (1-8 characters, case-insensitive)
     * Usage: Extracted from JWT token claims during authentication
     */
    @JsonProperty("userId")
    @NotBlank(message = "User ID is required for audit trail and authorization")
    @Size(min = 1, max = 8, message = "User ID must be between 1 and 8 characters")
    @Pattern(regexp = "^[A-Za-z0-9]+$", message = "User ID must contain only alphanumeric characters")
    private String userId;

    /**
     * Session identifier for distributed session management.
     * This field supports Redis-backed session storage and stateless microservices
     * architecture while maintaining user context across service boundaries.
     * 
     * Format: Alphanumeric string (32-128 characters)
     * Usage: Managed by Spring Session framework with Redis cluster
     */
    @JsonProperty("sessionId")
    @NotBlank(message = "Session ID is required for session management")
    @Size(min = 32, max = 128, message = "Session ID must be between 32 and 128 characters")
    @Pattern(regexp = "^[A-Za-z0-9\\-_]+$", message = "Session ID must contain only alphanumeric characters, hyphens, and underscores")
    private String sessionId;

    /**
     * Request timestamp for audit trail and transaction timing.
     * This field captures the exact time when the request was initiated,
     * supporting comprehensive audit requirements and transaction correlation.
     * 
     * Format: ISO-8601 LocalDateTime
     * Usage: Set by client or API gateway, used for audit trail and timeout handling
     */
    @JsonProperty("requestTimestamp")
    @NotNull(message = "Request timestamp is required for audit trail")
    private LocalDateTime requestTimestamp;

    /**
     * User role for authorization context (optional).
     * This field supports fine-grained access control and authorization decisions
     * at the service level, complementing JWT token-based authentication.
     * 
     * Format: Predefined role values (ADMIN, USER)
     * Usage: Extracted from JWT token claims, used for @PreAuthorize annotations
     */
    @JsonProperty("userRole")
    @Size(max = 20, message = "User role must not exceed 20 characters")
    @Pattern(regexp = "^(ADMIN|USER|ROLE_ADMIN|ROLE_USER)?$", message = "User role must be ADMIN, USER, ROLE_ADMIN, or ROLE_USER")
    private String userRole;

    /**
     * Client IP address for security monitoring and audit (optional).
     * This field supports security monitoring, fraud detection, and compliance
     * requirements for financial transaction processing.
     * 
     * Format: IPv4 or IPv6 address
     * Usage: Extracted from HTTP headers, used for security analysis
     */
    @JsonProperty("clientIpAddress")
    @Size(max = 45, message = "Client IP address must not exceed 45 characters")
    @Pattern(regexp = "^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)|(?:[0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}$", 
             message = "Client IP address must be a valid IPv4 or IPv6 address")
    private String clientIpAddress;

    /**
     * User agent string for client identification (optional).
     * This field supports security monitoring, client analytics, and audit trail
     * requirements for comprehensive request tracking.
     * 
     * Format: Standard HTTP User-Agent string
     * Usage: Extracted from HTTP headers, used for security analysis
     */
    @JsonProperty("userAgent")
    @Size(max = 512, message = "User agent must not exceed 512 characters")
    private String userAgent;

    /**
     * Default constructor for JSON deserialization.
     * Initializes request timestamp to current time for audit trail purposes.
     */
    public BaseRequestDto() {
        this.requestTimestamp = LocalDateTime.now();
    }

    /**
     * Constructor with required fields for programmatic instantiation.
     * 
     * @param correlationId Unique correlation identifier for request tracking
     * @param userId User identifier for audit trail and authorization
     * @param sessionId Session identifier for distributed session management
     */
    public BaseRequestDto(String correlationId, String userId, String sessionId) {
        this();
        this.correlationId = correlationId;
        this.userId = userId;
        this.sessionId = sessionId;
    }

    /**
     * Gets the correlation ID for distributed transaction tracking.
     * 
     * @return the correlation ID as a UUID string
     */
    public String getCorrelationId() {
        return correlationId;
    }

    /**
     * Sets the correlation ID for distributed transaction tracking.
     * 
     * @param correlationId the correlation ID as a UUID string
     */
    public void setCorrelationId(String correlationId) {
        this.correlationId = correlationId;
    }

    /**
     * Gets the user identifier for audit trail and authorization.
     * 
     * @return the user identifier
     */
    public String getUserId() {
        return userId;
    }

    /**
     * Sets the user identifier for audit trail and authorization.
     * 
     * @param userId the user identifier
     */
    public void setUserId(String userId) {
        this.userId = userId;
    }

    /**
     * Gets the session identifier for distributed session management.
     * 
     * @return the session identifier
     */
    public String getSessionId() {
        return sessionId;
    }

    /**
     * Sets the session identifier for distributed session management.
     * 
     * @param sessionId the session identifier
     */
    public void setSessionId(String sessionId) {
        this.sessionId = sessionId;
    }

    /**
     * Gets the request timestamp for audit trail and transaction timing.
     * 
     * @return the request timestamp
     */
    public LocalDateTime getRequestTimestamp() {
        return requestTimestamp;
    }

    /**
     * Sets the request timestamp for audit trail and transaction timing.
     * 
     * @param requestTimestamp the request timestamp
     */
    public void setRequestTimestamp(LocalDateTime requestTimestamp) {
        this.requestTimestamp = requestTimestamp;
    }

    /**
     * Gets the user role for authorization context.
     * 
     * @return the user role
     */
    public String getUserRole() {
        return userRole;
    }

    /**
     * Sets the user role for authorization context.
     * 
     * @param userRole the user role
     */
    public void setUserRole(String userRole) {
        this.userRole = userRole;
    }

    /**
     * Gets the client IP address for security monitoring.
     * 
     * @return the client IP address
     */
    public String getClientIpAddress() {
        return clientIpAddress;
    }

    /**
     * Sets the client IP address for security monitoring.
     * 
     * @param clientIpAddress the client IP address
     */
    public void setClientIpAddress(String clientIpAddress) {
        this.clientIpAddress = clientIpAddress;
    }

    /**
     * Gets the user agent string for client identification.
     * 
     * @return the user agent string
     */
    public String getUserAgent() {
        return userAgent;
    }

    /**
     * Sets the user agent string for client identification.
     * 
     * @param userAgent the user agent string
     */
    public void setUserAgent(String userAgent) {
        this.userAgent = userAgent;
    }

    /**
     * Validates the request context for security and audit compliance.
     * This method performs comprehensive validation of required fields and
     * security context to ensure proper request handling across microservices.
     * 
     * @return true if request context is valid, false otherwise
     */
    public boolean isValidRequestContext() {
        return correlationId != null && !correlationId.trim().isEmpty() &&
               userId != null && !userId.trim().isEmpty() &&
               sessionId != null && !sessionId.trim().isEmpty() &&
               requestTimestamp != null &&
               correlationId.matches("^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$") &&
               userId.matches("^[A-Za-z0-9]+$") &&
               sessionId.matches("^[A-Za-z0-9\\-_]+$");
    }

    /**
     * Creates a summary of the request context for audit logging.
     * This method generates a structured audit summary that supports
     * compliance requirements and security monitoring.
     * 
     * @return audit summary string
     */
    public String getAuditSummary() {
        return String.format("Request[correlationId=%s, userId=%s, sessionId=%s, timestamp=%s, role=%s, clientIp=%s]",
                           correlationId, userId, sessionId, requestTimestamp, userRole, clientIpAddress);
    }

    /**
     * Sanitizes sensitive fields for logging and debugging.
     * This method creates a version of the request with masked sensitive
     * information suitable for logging and debugging purposes.
     * 
     * @return sanitized request summary
     */
    public String getSanitizedSummary() {
        String maskedSessionId = sessionId != null ? sessionId.substring(0, 8) + "..." : null;
        String maskedClientIp = clientIpAddress != null ? 
                               clientIpAddress.substring(0, Math.min(clientIpAddress.length(), 8)) + "..." : null;
        
        return String.format("Request[correlationId=%s, userId=%s, sessionId=%s, timestamp=%s, role=%s, clientIp=%s]",
                           correlationId, userId, maskedSessionId, requestTimestamp, userRole, maskedClientIp);
    }

    /**
     * Equality comparison based on correlation ID and user context.
     * This method supports request deduplication and correlation tracking
     * across distributed microservices.
     * 
     * @param obj the object to compare
     * @return true if requests are equal, false otherwise
     */
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        
        BaseRequestDto that = (BaseRequestDto) obj;
        return Objects.equals(correlationId, that.correlationId) &&
               Objects.equals(userId, that.userId) &&
               Objects.equals(sessionId, that.sessionId) &&
               Objects.equals(requestTimestamp, that.requestTimestamp);
    }

    /**
     * Hash code generation based on correlation ID and user context.
     * This method supports efficient collections handling and request
     * correlation tracking in distributed systems.
     * 
     * @return hash code for the request
     */
    @Override
    public int hashCode() {
        return Objects.hash(correlationId, userId, sessionId, requestTimestamp);
    }

    /**
     * String representation for debugging and logging purposes.
     * This method provides a comprehensive string representation that
     * supports debugging while maintaining security best practices.
     * 
     * @return string representation of the request
     */
    @Override
    public String toString() {
        return getSanitizedSummary();
    }
}